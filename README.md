# Frigate Event Buffer

A state-aware orchestrator that listens to Frigate NVR events via MQTT, tracks them through their lifecycle, sends Ring-style sequential notifications to Home Assistant, and maintains a configurable rolling evidence locker (default 3 days). Includes a built-in event viewer and daily review summaries. Compatible with **Frigate 0.17+** with full GenAI review integration.

## Features

- **Frigate 0.17 Compatible**: Supports Frigate 0.17's new MQTT payload structure including `type: "genai"` review messages and `data.metadata` fields
- **MQTT Event Tracking**: Subscribes to Frigate's MQTT topics to detect and track events in real-time
- **Four-Phase Lifecycle**: Tracks events through NEW → DESCRIBED → FINALIZED → SUMMARIZED phases
- **Ring-Style Notifications**: Sends progressive updates to Home Assistant with phase-specific messages as event details emerge
- **GenAI Integration**: Captures GenAI titles, descriptions, and threat levels from (1) Frigate — via `data.metadata` in `frigate/reviews` and `description` in tracked object updates — and (2) optional **in-process Gemini analyzer**: when `gemini.enabled` in config, clips are analyzed via an OpenAI-compatible Gemini proxy; the service returns the result to the orchestrator, which updates state, writes summary/metadata, POSTs the description to Frigate's API (`/api/events/{id}/description`), and sends the "finalized" notification to Home Assistant. The buffer does **not** publish to `frigate/reviews` (that topic is Frigate output-only).
- **Multi-cam frame extractor**: When the Gemini analyzer is enabled, frame extraction uses a **YOLO AI model to track motion** (via detection sidecars), keeps first and last frames, and supports optional center crop or **smart crop** (when per-frame metadata from `frigate/+/tracked_object_update` is available). **Target-centric**: requires `detection.json` sidecars (generated by VideoService); if any camera lacks a sidecar, it returns empty (no HOG fallback). Configurable frame limits, crop size, and system prompt file. Writes **analysis_result.json** in each event folder (title, shortSummary, scene, potential_threat_level) for the Daily Report.
- **Daily Report**: At a configurable hour (default 1am), aggregates the previous calendar day's **analysis_result.json** files from event folders, builds a prompt from a template (e.g. `frigate_buffer/services/report_prompt.txt`), sends a text-only request to the Gemini proxy, and saves the AI-generated Markdown report to `{STORAGE_PATH}/daily_reports/YYYY-MM-DD_report.md`.
- **Review Summaries**: Fetches rich markdown security reports from Frigate's review summary API with cross-camera context, timeline, and assessments
- **Threat Level Alerts**: Three-tier threat classification (0=Normal, 1=Suspicious, 2=Critical) — Level 2 alerts bypass phone volume/DND and keep all follow-up notifications audible
- **Camera/Label Filtering**: Only process events from specific cameras or with specific labels
- **Smart Zone Filtering**: Optional per-camera tracked zones (create event only when object enters); exceptions (e.g., UPS, FedEx) trigger regardless of zone; Late Start when creation is triggered by a later update
- **Multi-Camera Support**: Handles events from multiple cameras simultaneously without state collision; supports **consolidated events** to group related activity across cameras into a single timeline.
- **Clip Export via Frigate API**: Requests clips from Frigate's Export API (POST with JSON body `playback`/`name` per Frigate schema; polls by `export_id` when async); full event duration with configurable buffer. For **consolidated events**, exports use per-camera time ranges and a representative event ID per camera (from sub-events) to avoid 404s and incorrect footage. Falls back to per-event clip via events API if export fails or times out; export failures log full raw response at WARNING for debugging; timeline includes full Frigate response; "Event ongoing" badge clears when clip is available, when Frigate signals event end (from timeline), or after 90 minutes
- **Raw clip pipeline**: Clips are downloaded from Frigate and stored as-is (H.264/H.265); no re-encoding. Detection sidecars (YOLO) are generated in a decode-only pass for multi-camera frame selection.
- **Clip Download Retry**: Retries clip downloads up to 3 times on HTTP 400 (Frigate not ready), with 5-second delays when using events API fallback. HTTP 404 (no recording available) is not retried—logged once and returns immediately
- **FFmpeg Safety**: 60-second timeout with graceful termination prevents zombie processes
- **Rolling Retention**: Automatically cleans up events older than the retention period (default: 3 days)
- **Export Watchdog**: Periodically (default every 2 minutes) scans event folders for completed Frigate exports recorded in `notification_timeline.json`, verifies the clip file exists locally, then calls Frigate's `DELETE /api/export/{export_id}` to remove the export from Frigate's list; treats HTTP 404/422 as "already removed" to prevent errors; also verifies download links (HEAD requests) for event files
- **Short Event Discard**: Events shorter than `minimum_event_seconds` (default 5s) are automatically discarded (data deleted, removed from state) to reduce noise; a "discarded" MQTT notification allows Home Assistant automation to clear the initial alert.
- **Notification Rate Limiting**: Max 2 notifications per 5 seconds with queue overflow protection
- **Built-in Event Viewer**: Self-contained web page at `/player` with video playback (multi-clip selector for consolidated events), expandable AI analysis (state preserved across auto-refresh; cross-camera review; single-camera shows "Review Summary"), "Event ongoing" badge clears when clip available, when Frigate signals event end (timeline), or after 90 min, event navigation, reviewed/unreviewed filtering, download, and **View Timeline** (per-event data pipeline log with all files including clips/snapshots from camera subdirs) — embeddable as an HA iframe. Includes a **TEST** button (for consolidated events with clips ready) that opens a test run page to execute the post-download pipeline (generate detection sidecar per camera, frame extraction, build AI request) without sending to the proxy; each run is saved as `test1`, `test2` under `events/`.
- **Stats Dashboard**: Stats as a header button (like Daily Review) linking to `/stats-page`; standalone stats page with event counts (today/week/month), Events by Camera (legacy camera folders and consolidated `events/`), API Usage (Month to Date API cost and token usage from HA helpers when configured), storage (Total, Clips/Snapshots/Descriptions breakdown, and by camera) in human-readable KB/MB/GB, recent errors, last cleanup, system info; configurable auto-refresh with manual Refresh button. Storage totals include legacy event folders, consolidated `events/{ce_id}/{camera}/` and CE-root files, and `daily_reports/` and `daily_reviews/`.
- **Daily Review**: Frigate review summarize integration — scheduled fetch at 1am for previous day, 90-day retention (configurable), date selector, "Current Day Review" for midnight-to-now; markdown rendering
- **Event Review Tracking**: Mark events as reviewed with per-event or bulk "mark all" controls; defaults to showing unreviewed events
- **REST API**: Serves events, clips, and snapshots to your Home Assistant dashboard
- **Debug Logging**: Configurable log levels for troubleshooting

## Architecture

The **StateAwareOrchestrator** is the central coordinator. It owns event-handling logic (frigate/events, tracked_object_update, reviews) and delegates to dedicated components:

- **MqttClientWrapper** (`services/mqtt_client.py`) — MQTT connection, subscriptions, and message callback; orchestrator provides the message handler.
- **SmartZoneFilter** (`managers/zone_filter.py`) — Per-camera zone/exception rules (tracked_zones, exceptions); decides whether to start an event.
- **TimelineLogger** (`services/timeline.py`) — Writes HA, MQTT, and Frigate API entries to event timeline files.
- **EventStateManager**, **FileManager**, **ConsolidatedEventManager**, **DailyReviewManager** — State, storage, consolidation, and daily reviews.
- **NotificationPublisher** — Publishes to `frigate/custom/notifications`; timeline callback is `TimelineLogger.log_ha`.
- **Flask** — Web API (player, events, files, stats, daily review, status).

### Refactor Additions (This Fork)

- **VideoService** (`services/video.py`) — Decode-only frame reading (ffmpegcv/NVDEC), detection sidecar generation (YOLO), and GIF generation; no encoding.
- **EventLifecycleService** (`services/lifecycle.py`) — Handles event creation, event end (clip export, cleanup), and consolidated-event finalization (export, review summary, notifications); orchestrator delegates to it instead of inlining logic.
- **GeminiAnalysisService** (`services/ai_analyzer.py`) — Optional. When `gemini.enabled`, extracts frames (motion-aware selection, optional center/smart crop from per-frame metadata), sends them to an OpenAI-compatible Gemini proxy, and **returns** the analysis metadata to the orchestrator. Writes **analysis_result.json** in the event folder for the Daily Report. Does not publish to MQTT; the orchestrator persists the result (state, files, Frigate API, HA notification).
- **DailyReporterService** (`services/daily_reporter.py`) — Optional. When the Gemini analyzer is enabled, runs at **DAILY_REPORT_SCHEDULE_HOUR** (default 1am) for the previous calendar day: scans storage for **analysis_result.json** in event folders, aggregates event lines, fills the report prompt template (e.g. `report_prompt.txt`), calls **send_text_prompt** on the analyzer (text-only, no images), and writes the proxy response to `{STORAGE_PATH}/daily_reports/{date}_report.md`.
- **EventQueryService** (`services/query.py`) — Reads and parses event data from the filesystem with TTL and per-folder caching; used by the Flask server for event lists and stats so path and parsing logic are centralized.
- **NotificationEvent protocol** (`models.py`) — Shared interface for EventState and ConsolidatedEvent so the notifier accepts a single contract.
- **ConsolidatedEventManager “closing” state** — A CE can be `closing` before removal; `mark_closing(ce_id)` prevents new sub-events and timer rescheduling; avoids races during finalization.
- **FileManager path validation** — Camera names and folder paths are checked with `os.path.realpath` and `commonpath` so paths cannot escape the storage root; invalid inputs raise `ValueError`.
- **Config schema validation** — When a config file is present, it is validated with a **voluptuous** schema before use; invalid config exits at startup with a clear error (see [Configuration validation](#configuration-validation)).
- **Export Watchdog** (`services/frigate_export_watchdog.py`) — Scheduled by the orchestrator (default every 2 minutes). Reads `notification_timeline.json` in event folders (legacy and consolidated), finds "Clip export response" entries with `export_id`, verifies the corresponding clip file exists, then deletes the export from Frigate via `DELETE /api/export/{export_id}` (HTTP 404/422 treated as success/already removed); optionally verifies buffer download URLs with HEAD requests.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    StateAwareOrchestrator (coordinator)                   │
├─────────────────────────────────────────────────────────────────────────┤
│  MqttClientWrapper     EventStateManager    SmartZoneFilter   Flask API  │
│  ├─ connect/subscribe  ├─ active_events     ├─ should_start   ├─ /player │
│  ├─ on_message →       ├─ phase tracking    │   _event        ├─ /events │
│  │   orchestrator     │   NEW→DESCRIBED     └─ exceptions +   ├─ /files  │
│  └─ frigate/events,   │   →FINALIZED           tracked_zones  ├─ /stats  │
│      tracked_object,   │   →SUMMARIZED                         ├─ /stats-│
│      reviews           │                                       │   page   │
│  TimelineLogger        FileManager          ConsolidatedEvent  ├─ /daily- │
│  ├─ folder_for_event  ├─ clip/snapshot     ├─ get_or_create   │   review │
│  ├─ log_ha / log_mqtt │   export/transcode ├─ schedule_close  └─ /status │
│  └─ log_frigate_api    └─ cleanup           └─ on_close → orchestrator   │
│  NotificationPublisher DailyReviewManager                                │
│  └─ timeline_callback = TimelineLogger.log_ha                            │
└─────────────────────────────────────────────────────────────────────────┘
```

## Project Structure

The application uses a **src layout**: the package lives in `src/frigate_buffer/`. Install from repo root with `pip install -e .`; then run `python -m frigate_buffer.main`. Paths below are relative to the package (e.g. `main.py` is `src/frigate_buffer/main.py`).

| File / Directory | Description |
|------------------|-------------|
| `main.py` | Entry point. Loads config, sets up logging and signal handlers, starts the orchestrator. Run with `python -m frigate_buffer.main`. |
| `config.py` | Configuration loading and validation. When a config file exists, validates with a voluptuous schema (required `cameras`, optional `network`/`settings`/`ha`/`multi_cam`/`gemini_proxy`; invalid config exits with code 1). Merges YAML, env vars, and defaults. No Google fallback; single API key (`GEMINI_API_KEY`). Searches config paths in order. |
| `logging_utils.py` | Error buffer and logging. `ErrorBuffer` stores recent errors for the stats dashboard; `setup_logging()` configures log level and handlers. |
| `models.py` | Data models: `EventPhase`, `EventState`, `ConsolidatedEvent`, `FrameMetadata` (per-frame tracked object data), `NotificationEvent` protocol; helpers for consolidated IDs and "no concerns" detection (`NO_CONCERNS_PATTERNS`, `_is_no_concerns`). |
| `orchestrator.py` | `StateAwareOrchestrator` — Central coordinator: MQTT message routing (`_on_mqtt_message`), event handlers (frigate/events, tracked_object_update, reviews), CE close and event-end processing. Delegates to MqttClientWrapper, SmartZoneFilter, TimelineLogger, and managers. |
| `managers/` | Business logic modules: |
| `managers/file.py` | `FileManager` — clip/snapshot download, storage paths, cleanup; transcoding delegated to `VideoService`. Path validation via `realpath`/`commonpath` prevents traversal outside storage. **Storage stats** (`compute_storage_stats`): sums clips, snapshots, and description files for legacy layout (`{camera}/{event_id}/`), consolidated layout (`events/{ce_id}/` CE-root files and `events/{ce_id}/{camera}/` per-camera files), and `daily_reports/` and `daily_reviews/`; returns bytes by type and by_camera for the stats dashboard. Export API uses JSON body (`playback`, `name`), polls by export_id, 90s poll timeout, 180s download timeout; returns rich result with Frigate response for timeline debugging. Export failures and `success: false` responses are logged at WARNING with full raw response. HTTP 404 on clip download is treated as "no recording available" and returns False without retries; retries remain for HTTP 400 (Not Ready) and other transient errors. |
| `managers/state.py` | `EventStateManager` — per-event state (phase, metadata) and active event tracking. |
| `managers/consolidation.py` | `ConsolidatedEventManager` — groups related Frigate events; supports `closing` state and `mark_closing()` to avoid races during finalization. |
| `managers/reviews.py` | `DailyReviewManager` — fetches and caches Frigate daily review summaries. |
| `managers/zone_filter.py` | `SmartZoneFilter` — per-camera `CAMERA_EVENT_FILTERS` (tracked_zones, exceptions); `should_start_event` and `normalize_sub_label`. |
| `services/` | External integrations and utilities: |
| `services/video.py` | `VideoService` — Decode-only detection sidecar (`generate_detection_sidecar`) and GIF generation; used by FileManager. No encoding; clips used as-is. |
| `services/lifecycle.py` | `EventLifecycleService` — event creation, event end processing, and consolidated-event finalization; orchestrator delegates to it. |
| `services/query.py` | `EventQueryService` — reads event data from filesystem with TTL and per-folder caching; used by Flask for event lists and stats. |
| `services/notifier.py` | `NotificationPublisher` — publishes MQTT notifications to Home Assistant; accepts `NotificationEvent` protocol; optional `timeline_callback` (e.g. `TimelineLogger.log_ha`). |
| `services/timeline.py` | `TimelineLogger` — resolves event/CE folder and appends HA, MQTT, and Frigate API entries to `notification_timeline.json` via `FileManager`. |
| `services/mqtt_client.py` | `MqttClientWrapper` — Paho MQTT client lifecycle (connect, subscribe, loop), connect/disconnect logging; exposes `client` and `mqtt_connected`; message handling delegated to orchestrator callback. Requires `paho-mqtt>=2.0.0` (CallbackAPIVersion.VERSION2). |
| `services/ai_analyzer.py` | `GeminiAnalysisService` — Optional. When gemini config is enabled, analyzes clips with motion-aware frame selection (single-cam: grayscale differencing; multi-cam: YOLO-based detection sidecars), optional center/smart crop from per-frame metadata, configurable prompt file; sends frames to Gemini proxy; returns metadata to the orchestrator; writes **analysis_result.json** in the event folder. No MQTT publish; orchestrator updates state, writes files, POSTs to Frigate API, and notifies HA. Prompt template: `ai_analyzer_system_prompt.txt` (same dir) or `MULTI_CAM_SYSTEM_PROMPT_FILE`. |
| `services/daily_reporter.py` | `DailyReporterService` — Optional. When analyzer is enabled, scheduled at **DAILY_REPORT_SCHEDULE_HOUR** (default 1am): scans storage for **analysis_result.json**, filters by target date, builds event list and prompt from **report_prompt.txt** (or `REPORT_PROMPT_FILE`), calls analyzer `send_text_prompt`, writes Markdown to `{STORAGE_PATH}/daily_reports/{date}_report.md`. |
| `services/download.py` | `DownloadService` — Frigate API: snapshot download, clip export/download (dynamic names, no transcode), review summary fetch. Also `post_event_description(event_id, description)` to POST AI result to Frigate (`/api/events/{id}/description`). |
| `services/frigate_export_watchdog.py` | Export watchdog: `run_once(config)` parses `notification_timeline.json` in event folders (legacy and consolidated), finds completed export IDs, verifies clip files exist, calls Frigate `DELETE /api/export/{export_id}`, and optionally verifies buffer file URLs. Invoked on a schedule by the orchestrator. |
| `web/server.py` | Flask app factory `create_app(orchestrator)`. Routes for player, events, files, stats, daily review, API, and test pipelines (`/test-multi-cam`, `/api/test-multi-cam/...`). |
| `web/templates/` | Jinja2 templates (player, stats, daily review, timeline). Used by Flask at runtime. |
| `web/static/` | Static assets (marked.min.js, purify.min.js). |
| `scripts/multi_cam_recap.py` | **Standalone entrypoint**: Optional multi-cam frame extraction and MQTT-driven processing. Run with the package installed (`pip install -e .` then `python scripts/multi_cam_recap.py`). Not invoked by the main orchestrator. |
| `Dockerfile` | Builds from Python 3.12 slim; copies `src/` and `pyproject.toml`, runs `pip install -e .`, then `python -m frigate_buffer.main`. |
| `docker-compose.example.yaml` | Template for Docker Compose — local build or token pull from private GitHub. |
| `config.example.yaml` | Example configuration for cameras, event_filters (Smart Zone Filtering), settings, network, optional HA integration. |
| `tests/` | Unit tests (`test_*.py`). Run with `pytest tests/` (or `python -m pytest tests/`); `pyproject.toml` sets `pythonpath = ["src"]`. See [Tests](#tests). |

## Quick Start

### 1. Build the Docker Image

From the project root (cloned repo):

```bash
docker build -t frigate-buffer .
```

### 2. Run the Container

```bash
docker run -d \
  --name frigate-buffer \
  -p 5055:5055 \
  -v /mnt/user/appdata/frigate_buffer:/app/storage \
  frigate-buffer
```

### 3. Verify It's Running

```bash
curl http://localhost:5055/status
```

### Running without Docker

Requires **Python 3.12+**. From the project root, install the package in editable mode (which installs dependencies), then run:

```bash
pip install -e .
python -m frigate_buffer.main
```

The app searches for `config.yaml` in order at: `/app/config.yaml`, `/app/storage/config.yaml`, `./config.yaml`, and `config.yaml`. No separate path configuration is needed.

## Configuration

Configuration is loaded from three sources (in order of priority):

1. **Environment variables** (highest priority)
2. **config.yaml** file (searched at `/app/config.yaml`, `/app/storage/config.yaml`, `./config.yaml`, and `config.yaml` in the current working directory)
3. **Default values** (lowest priority)

Place your `config.yaml` inside the storage volume (e.g. `/mnt/user/appdata/frigate_buffer/config.yaml`); the app finds it at `/app/storage/config.yaml` automatically. No separate bind mount is required. You can optionally bind-mount a config file to `/app/config.yaml` instead.

### config.yaml

Copy the example config and customize it:

```bash
cp config.example.yaml config.yaml
# Edit config.yaml with your values
```

The config file structure:

```yaml
# Camera configuration with per-camera label filtering
# Only events from listed cameras will be processed
# Omit a camera entirely to filter it out
cameras:
  # Doorbell - only person and package events
  - name: "Doorbell"
    labels:
      - "person"
      - "package"

  # Driveway - only vehicle events (with Smart Zone Filtering example)
  - name: "Front_Yard"
    labels:
      - "car"
      - "truck"
    # event_filters:     # Optional - omit for legacy behavior
    #   tracked_zones:   # Only create when object enters these zones
    #     - driveway
    #   exceptions:      # Create regardless of zone
    #     - "UPS"
    #     - "FedEx"

  # Backyard - allow ALL labels (empty list)
  - name: "Carport"
    labels: []

# Application settings
settings:
  retention_days: 3
  cleanup_interval_hours: 1
  ffmpeg_timeout_seconds: 60
  notification_delay_seconds: 2  # Delay before fetching snapshot after initial notification
  log_level: "DEBUG"  # DEBUG, INFO, WARNING, ERROR
  summary_padding_before: 15   # Seconds before event start for review summary
  summary_padding_after: 15    # Seconds after event end for review summary
  stats_refresh_seconds: 60    # Stats panel auto-refresh interval (seconds)
  daily_review_retention_days: 90   # How long to keep saved daily reviews (days)
  daily_review_schedule_hour: 1     # Hour (0-23) to fetch previous day's review
  daily_report_schedule_hour: 1     # Hour (0-23) to run Daily Report (aggregate analysis_result.json → Gemini → daily_reports/)
  report_prompt_file: ""            # Path to report prompt template; empty = use built-in report_prompt.txt
  report_known_person_name: ""      # Placeholder {known_person_name} in report prompt; default "Unspecified" when empty
  event_gap_seconds: 120      # Seconds of no activity before new consolidated event
  export_buffer_before: 5     # Seconds before event start for clip export time range
  export_buffer_after: 30    # Seconds after event end for clip export time range
  export_watchdog_interval_minutes: 2   # How often to run export watchdog (remove completed exports from Frigate, verify links)

# Network configuration (REQUIRED - no defaults)
network:
  mqtt_broker: "YOUR_MQTT_BROKER_IP"
  mqtt_port: 1883
  # mqtt_user: ""              # Optional MQTT authentication
  # mqtt_password: ""
  frigate_url: "http://YOUR_FRIGATE_IP:5000"
  buffer_ip: "YOUR_BUFFER_IP"  # IP where this container is reachable
  flask_port: 5055
  storage_path: "/app/storage"

# Optional: Home Assistant REST API (for stats page API Usage display)
# ha:
#   base_url: "http://YOUR_HA_IP:8123/api"
#   token: "YOUR_LONG_LIVED_ACCESS_TOKEN"
#   gemini_cost_entity: "input_number.gemini_daily_cost"
#   gemini_tokens_entity: "input_number.gemini_total_tokens"
```

### Configuration validation

When a **config file is found** (at any of the searched paths), the buffer validates it with a **voluptuous** schema before merging with defaults and environment variables. This catches typos, wrong types, and missing required keys at startup.

- **When validation runs**: Only when `config.yaml` (or equivalent) exists and is loaded. If no config file is found, the app uses defaults and environment variables only and does not run schema validation.
- **Required**: The root key `cameras` is **required** and must be a list. Each camera entry must have at least `name` (string). This ensures every config file declares which cameras to process.
- **Optional sections**: `network`, `settings`, `ha`, `multi_cam`, and `gemini_proxy` are optional. Within them, fields have enforced types (e.g. `mqtt_port` must be an int, `log_level` must be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`). `settings` may include `export_watchdog_interval_minutes`, `report_prompt_file`, `report_known_person_name`, `final_review_image_count`, `gemini_max_concurrent_analyses`, `gemini_frames_per_hour_cap` (rolling limit for proxy requests, default 200), and others. `network` may include `mqtt_user` and `mqtt_password` for MQTT authentication.
- **Schema rules**: `cameras[].event_filters` may contain `tracked_zones` (list of strings) and `exceptions` (list of strings). Extra keys at the root are allowed (`ALLOW_EXTRA`), so you can add custom keys without validation errors.
- **On failure**: If validation fails, the app logs the error (e.g. `Invalid configuration in /app/config.yaml: required key not provided @ data['cameras']`) and exits with code 1. Fix the config file and restart.
- **Dependency**: Validation requires the `voluptuous` package (listed in `requirements.txt`).

### Environment Variables

Environment variables override config.yaml values:

| Variable | Default | Description |
|----------|---------|-------------|
| `MQTT_BROKER` | *(required)* | MQTT broker IP address |
| `MQTT_PORT` | `1883` | MQTT broker port |
| `BUFFER_IP` | *(required)* | Buffer container's reachable IP (used in notification image/video URLs) |
| `HA_IP` | *(optional)* | Fallback for BUFFER_IP if set (for compatibility) |
| `FRIGATE_URL` | *(required)* | Frigate API base URL |
| `STORAGE_PATH` | `/app/storage` | Storage directory inside container |
| `RETENTION_DAYS` | `3` | Days to retain event folders |
| `FLASK_PORT` | `5055` | Flask server port |
| `LOG_LEVEL` | `INFO` | Logging level (DEBUG, INFO, WARNING, ERROR) |
| `STATS_REFRESH_SECONDS` | `60` | Stats panel auto-refresh interval (seconds) |
| `DAILY_REVIEW_RETENTION_DAYS` | `90` | Days to retain saved daily reviews |
| `DAILY_REVIEW_SCHEDULE_HOUR` | `1` | Hour (0-23) to run daily review fetch for previous day |
| `EVENT_GAP_SECONDS` | `120` | Seconds without activity before new consolidated event |
| `EXPORT_BUFFER_BEFORE` | `5` | Seconds before event start for clip export time range |
| `EXPORT_BUFFER_AFTER` | `30` | Seconds after event end for clip export time range |
| `EXPORT_WATCHDOG_INTERVAL_MINUTES` | `2` | How often to run the export watchdog (minutes). |
| `HA_URL` | *(optional)* | Home Assistant API base URL, e.g. `http://YOUR_HA_IP:8123/api` (for stats page API Usage display) |
| `HA_TOKEN` | *(optional)* | Home Assistant long-lived access token (for stats page API Usage display) |
| `GEMINI_API_KEY` | *(optional)* | API key for the Gemini proxy (single key for all proxy usage; overrides `gemini.api_key` in config). |
| `GEMINI_PROXY_URL` | *(optional)* | Overrides proxy URL for Gemini (e.g. multi-cam). No default fallback; set explicitly in config or env. |
| `DAILY_REPORT_SCHEDULE_HOUR` | `1` | Hour (0–23) to run the Daily Report job for the previous calendar day. |
| `REPORT_PROMPT_FILE` | *(empty)* | Path to report prompt template for Daily Report; empty = use `frigate_buffer/services/report_prompt.txt`. |
| `REPORT_KNOWN_PERSON_NAME` | *(empty)* | Value for `{known_person_name}` in report prompt; empty = "Unspecified". |
| `MQTT_USER` | *(optional)* | MQTT broker username (when auth required). |
| `MQTT_PASSWORD` | *(optional)* | MQTT broker password. |

Optional **gemini** config section (in `config.yaml`): `proxy_url`, `api_key`, `model`, `enabled`. When `enabled` is true and proxy is configured, the buffer runs in-process clip analysis via the proxy, then updates state, writes files, POSTs the description to Frigate, and notifies HA.

### Multi-cam frame extractor and Daily Report

When **gemini.enabled** is true, the buffer uses **GeminiAnalysisService** for clip analysis and optionally **DailyReporterService** for a daily AI report.

**Frame extraction (multi-cam):** Optional **multi_cam** and **gemini_proxy** sections in `config.yaml` (see `config.example.yaml`) control frame limits (`max_multi_cam_frames_min`, `max_multi_cam_frames_sec`), motion-aware selection (uses **detection.json** sidecars; see [VideoService](#refactor-additions-this-fork) and `multi_cam.detection_model`), center/smart crop (`crop_width`, `crop_height`, `smart_crop_padding`), and proxy tuning (temperature, top_p, frequency_penalty, presence_penalty). The analyzer loads its system prompt from **multi_cam.multi_cam_system_prompt_file** (flat key `MULTI_CAM_SYSTEM_PROMPT_FILE`); if empty, it uses the built-in `frigate_buffer/services/ai_analyzer_system_prompt.txt`. Per-frame metadata from `frigate/+/tracked_object_update` is used when available for smart crop and score-based frame selection. After a successful proxy response, the analyzer writes **analysis_result.json** (title, shortSummary, scene, potential_threat_level, etc.) in the same directory as the clip (event folder); this file is the input for the Daily Report.

**Daily Report:** At **DAILY_REPORT_SCHEDULE_HOUR** (default 1am), the buffer builds the event list for the previous calendar day and fills the report prompt template. Event data comes **only from events that have an analysis_result.json** (i.e. that completed AI analysis). The report date is the **server’s local calendar day**—timezone can affect which events fall in “yesterday”. Event list source: if **daily_reports/aggregate_YYYY-MM-DD.jsonl** exists (events are appended there as each analysis result is saved), the report reads from it; otherwise it scans **STORAGE_PATH** for **analysis_result.json** in event folders (single-cam: `camera/timestamp_eventid/`; consolidated: `events/timestamp_uuid/`). After a successful report, the aggregate file for that date is deleted. The template is loaded from **REPORT_PROMPT_FILE** or the bundled `frigate_buffer/services/report_prompt.txt` (shipped with the package). If the prompt file is missing or unreadable, the daily report is skipped (no in-code fallback); see logs for the path and reason. Placeholders: `{report_start_time}`, `{report_end_time}`, `{report_date_string}`, `{known_person_name}` (from config **REPORT_KNOWN_PERSON_NAME** or settings, default "Unspecified"), and `{list_of_event_json_objects}`. The placeholders `{event_list}` and `{list_of_event_json_objects}` are filled with the same JSON array; `{date}` is still replaced for backward compatibility with custom prompts. The buffer sends a text-only request to the same Gemini proxy (no images) and writes the response to **{STORAGE_PATH}/daily_reports/YYYY-MM-DD_report.md**. Edit the prompt file to change report style. No separate API or UI for Daily Report; the file is written to disk for you to open or integrate elsewhere.

## Daily Review

The Daily Review feature integrates with [Frigate's Review Summarize API](https://docs.frigate.video/configuration/genai/genai_review) to fetch and display AI-generated security summaries. The buffer stores these reviews separately from event clips (90-day retention by default).

### GET /stats-page

Standalone stats dashboard. Opens from the "Stats" button in the player header. Shows: API Usage (Month to Date cost/tokens from HA helpers when configured), Event Counts, Events by Camera, Storage, Recent Activity, Errors, System. Configurable auto-refresh (`stats_refresh_seconds`), manual Refresh button. "Back to Events" links to `/player`.

### GET /daily-review

Web page with date selector and formatted markdown review. Opens from the "Daily Review" button in the player header.

- **Date dropdown**: Select any available date; defaults to previous day
- **Load Review**: Fetch/cache review for selected date from Frigate
- **Current Day Review**: Fetch today's review (midnight to current time) from Frigate

### GET /api/daily-review/dates

List available cached review dates.

### GET /api/daily-review/{date}

Get review for date (YYYY-MM-DD). Fetches from Frigate if not cached. Use `?force=1` to re-fetch.

### GET /api/daily-review/current

Fetch current day review (midnight to now) from Frigate. Saves as partial review for today.

### Scheduled Job

At the configured hour (default 1am), the buffer fetches the previous day's review from Frigate and saves it. Old reviews are removed based on `daily_review_retention_days`.

### Daily Report (AI-generated from event analyses)

Separate from Frigate's Daily Review (which fetches Frigate's review summarize API), the buffer can generate its **own** daily report from the events it has analyzed with the Gemini proxy. When **gemini.enabled** is true, the analyzer writes **analysis_result.json** in each event folder after each clip analysis. At **DAILY_REPORT_SCHEDULE_HOUR** (default 1am), **DailyReporterService** scans storage for those files for the **previous calendar day**, builds an event list, fills a report prompt template (e.g. `frigate_buffer/services/report_prompt.txt`), sends a text-only request to the Gemini proxy, and saves the response as **{STORAGE_PATH}/daily_reports/YYYY-MM-DD_report.md**. Configure the schedule and prompt file via [Multi-cam frame extractor and Daily Report](#multi-cam-frame-extractor-and-daily-report); the report file is written to disk for you to open or integrate elsewhere.

## Camera/Label Filtering

The orchestrator filters events on a per-camera basis. Filter order: **camera/label first**, then **Smart Zone Filtering** (if `event_filters` is configured).

- **Camera must be listed**: Cameras not in the config are filtered out entirely
- **Per-camera labels**: Each camera can have its own label whitelist
- **Empty labels = allow all**: If `labels: []` is empty, all labels are allowed for that camera
- **Filtered events**: Events that don't match are silently ignored (visible in DEBUG logs)

Example: Different labels for different cameras:

```yaml
cameras:
  # Doorbell - only person and package events
  - name: "Doorbell"
    labels:
      - "person"
      - "package"

  # Driveway - only vehicle events
  - name: "Driveway"
    labels:
      - "car"

  # Backyard - allow ALL labels
  - name: "Backyard"
    labels: []
```

## Smart Zone Filtering

Optional per-camera `event_filters` reduce background noise by creating events **only** when an object enters a tracked zone (e.g., driveway). Exceptions create events regardless of zone.

**Flow:** The buffer listens for both `type: new` and `type: update` on `frigate/events`. For each message, if the event is not yet tracked, it runs the decision tree: (1) Does the label or sub_label match an exception? → Start immediately. (2) Has the object entered any zone in `tracked_zones`? → Start. (3) Otherwise → Defer. Each `update` re-evaluates until the event is created.

- **tracked_zones**: Frigate zone names. Create an event **only** when the object enters one of these zones. A car on the road is deferred until it enters the driveway.
- **exceptions**: Labels or sub_labels (e.g. `person`, `UPS`, `FedEx`) that create an event regardless of zone. Put both in the same list; matching is case-insensitive.
- **Late Start**: When an event is first created from an `update` message (e.g., car enters driveway), the original `start_time` from the payload is used so clips and review windows cover the full event.

Omit `event_filters` for legacy behavior (all events start immediately on `new`). At startup, the buffer logs `Smart Zone Filtering:` with per-camera `tracked_zones` and `exceptions` when configured.

```yaml
  - name: "Front_Yard"
    labels:
      - "car"
      - "truck"
    event_filters:
      tracked_zones:
        - driveway
      exceptions:
        - "person"
        - "UPS"
        - "FedEx"
```

## API Endpoints

### GET /events/<camera>/<subdir>/timeline

Per-event notification timeline page. Shows data received from Frigate (MQTT), clip export request/response (including full Frigate API response for debugging failures), Frigate Review Summarize API requests/responses, and payloads sent to Home Assistant. Rendered from `notification_timeline.json` in the event folder.

- **Back to Player** — links to `/player?camera=X&subdir=Y` so the player opens on the same event
- **Download Timeline** — downloads `notification_timeline.json`
- **Event Files** — download links for all files: root-level (notification_timeline.json, review_summary.md, summary.txt, metadata.json, ai_analysis_debug.zip); and per-camera subdirs (clip.mp4, snapshot.jpg, metadata.json, etc.) for consolidated events

### GET /player

Built-in event viewer web page. Open in a browser or embed as an HA iframe card.

Features:
- Single-column responsive layout (scales to any device)
- HTML5 video player with snapshot poster
- Expandable AI analysis: each GenAI event from the timeline with its own expand/collapse (Expand button only shown when content is truncated); identical descriptions are deduplicated so each unique analysis is shown once (raw timeline keeps all entries for debugging); cross-camera review (or "Review Summary" when single camera); "No activity" boilerplate hidden when GenAI data is present
- Event Details (Cameras & Zones, label, timestamp): shows all cameras with affected zones from timeline (e.g., `Doorbell: Front_Porch, Front Yard` / `Carport: No Zones Indicated`)
- Camera filter dropdown
- Reviewed/Unreviewed/All filter (defaults to unreviewed)
- Stats button in header — links to `/stats-page` (standalone stats dashboard)
- "View most recent notification" link loads `/player?filter=all` so the most recent event is shown first (ignores reviewed/unreviewed filter)
- "Mark Reviewed" per-event and "Mark All Reviewed" bulk action
- Prev/Next event navigation
- Download and delete buttons
- **View Timeline** link — opens per-event page showing data from Frigate, Frigate API requests/responses, and HA notification payloads (saved as `notification_timeline.json`)
- Auto-refresh every 30 seconds (pauses during video playback)
- When no events: "No Events Found" with link to Stats page
- Dark theme optimized for HA dark mode

```
http://YOUR_BUFFER_IP:5055/player
```

### GET /cameras

List available cameras.

```bash
curl http://localhost:5055/cameras
```

Response:
```json
{
  "cameras": ["doorbell", "front_yard"],
  "default": "doorbell"
}
```

### GET /events

List all events across all cameras (global view).

**Query Parameters:**
- `?filter=unreviewed` (default) — only unreviewed events
- `?filter=reviewed` — only reviewed events
- `?filter=all` — all events

```bash
curl http://localhost:5055/events
curl http://localhost:5055/events?filter=all
```

Response:
```json
{
  "cameras": ["doorbell", "front_yard"],
  "total_count": 5,
  "events": [
    {
      "event_id": "1234567890.123-abcdef",
      "camera": "doorbell",
      "subdir": "1234567890_1234567890.123-abcdef",
      "timestamp": "1234567890",
      "label": "person",
      "title": "Person at Front Door",
      "description": "A person in blue jacket approaching the door",
      "severity": "alert",
      "threat_level": 0,
      "review_summary": "# Security Summary...",
      "summary": "Event ID: ...\nCamera: ...",
      "has_clip": true,
      "has_snapshot": true,
      "viewed": false,
      "ongoing": false,
      "hosted_clip": "/files/doorbell/1234567890_eventid/clip.mp4",
      "hosted_snapshot": "/files/doorbell/1234567890_eventid/snapshot.jpg",
      "cameras_with_zones": [{"camera": "doorbell", "zones": ["Front_Porch", "Front Yard"]}],
      "genai_entries": [{"title": "Person at door", "shortSummary": "...", "scene": "...", "time": "Friday, 2:30 PM"}]
    }
  ]
}
```

`genai_entries` are deduplicated by title, shortSummary, and scene so each unique analysis appears once; the raw `notification_timeline.json` still contains all timeline entries for debugging.

### GET /events/{camera}

List events for a specific camera.

**Query Parameters:**
- `?filter=unreviewed` (default) — only unreviewed events
- `?filter=reviewed` — only reviewed events
- `?filter=all` — all events

```bash
curl http://localhost:5055/events/doorbell
curl http://localhost:5055/events/doorbell?filter=all
```

### GET /files/{path}

Serve stored files (clips, snapshots). Clips are stored as H.264/H.265 from Frigate (no re-encode).

```bash
curl http://localhost:5055/files/doorbell/1234567890_eventid/clip.mp4 --output clip.mp4
```

### POST /delete/{folder}

Manually delete an event folder.

```bash
curl -X POST http://localhost:5055/delete/doorbell/1234567890_eventid
```

### POST /viewed/{camera}/{subdir}

Mark a specific event as reviewed.

```bash
curl -X POST http://localhost:5055/viewed/doorbell/1234567890_eventid
```

### DELETE /viewed/{camera}/{subdir}

Remove the reviewed marker from an event.

```bash
curl -X DELETE http://localhost:5055/viewed/doorbell/1234567890_eventid
```

### POST /viewed/all

Mark all events across all cameras as reviewed.

```bash
curl -X POST http://localhost:5055/viewed/all
```

### GET /stats

Get statistics for the stats dashboard (events, storage, errors, system). Used by the Stats page. When HA is configured via `ha.base_url` and `ha.token` in config.yaml, optionally includes `ha_helpers` with `gemini_month_cost` and `gemini_month_tokens` from HA input_number helpers.

```bash
curl http://localhost:5055/stats
```

Response:
```json
{
  "events": {
    "today": 12,
    "this_week": 45,
    "this_month": 120,
    "total_reviewed": 80,
    "total_unreviewed": 40,
    "by_camera": {"doorbell": 60, "front_yard": 60, "events": 30}
  },
  "ha_helpers": {
    "gemini_month_cost": 0.00123,
    "gemini_month_tokens": 1234567
  },
  "storage": {
    "total_display": {"value": 205.5, "unit": "MB"},
    "by_camera": {"doorbell": {"value": 100, "unit": "MB"}, "front_yard": {"value": 105.5, "unit": "MB"}, "events": {"value": 500, "unit": "KB"}},
    "breakdown": {"clips": {"value": 200, "unit": "MB"}, "snapshots": {"value": 5, "unit": "MB"}, "descriptions": {"value": 512, "unit": "KB"}}
  },
  "errors": [
    {"ts": "2025-02-12 10:30:00", "level": "ERROR", "message": "FFmpeg timeout for event xyz"}
  ],
  "last_cleanup": {"at": "2025-02-12 09:00:00", "deleted": 5},
  "most_recent": {"event_id": "abc123", "camera": "doorbell", "url": "/player?filter=all", "timestamp": 1707742800},
  "system": {
    "uptime_seconds": 3600,
    "mqtt_connected": true,
    "active_events": 2,
    "retention_days": 3,
    "cleanup_interval_hours": 1,
    "stats_refresh_seconds": 60,
    "storage_path": "/app/storage"
  }
}
```

Errors are limited to the last 10 (see container logs for full history). **Event counts**: Top-level dirs under storage are scanned (legacy camera folders and `events/`); for `events/`, each direct child is a consolidated event (CE) folder, so `by_camera.events` is the count of CE folders. **Storage**: `total_display` and each entry in `breakdown` and `by_camera` use `{value, unit}` with unit one of `KB`, `MB`, or `GB` (chosen for readability, e.g. 500 KB instead of 0.5 MB). Storage totals include legacy event folders, consolidated `events/{ce_id}/{camera}/` and CE-root files, and `daily_reports/` and `daily_reviews/`. The `most_recent.url` links to `/player?filter=all` so the most recent event is shown first when the page loads. The `ha_helpers` object is optional and only included when HA is configured via `ha.base_url` and `ha.token` in config.yaml (or `HA_URL` and `HA_TOKEN` env vars).

### GET /status

Get orchestrator health status (for monitoring).

```bash
curl http://localhost:5055/status
```

Response:
```json
{
  "online": true,
  "mqtt_connected": true,
  "uptime_seconds": 3661.5,
  "uptime": "1:01:01",
  "started_at": "2024-01-15 10:30:00",
  "active_events": {
    "total_active": 2,
    "by_phase": {"NEW": 1, "DESCRIBED": 1, "FINALIZED": 0, "SUMMARIZED": 0},
    "by_camera": {"Doorbell": 2}
  },
  "config": {
    "retention_days": 3,
    "log_level": "DEBUG",
    "ffmpeg_timeout": 60,
    "summary_padding_before": 15,
    "summary_padding_after": 15
  }
}
```

## MQTT Notifications

The orchestrator publishes notifications to `frigate/custom/notifications`:

```json
{
  "event_id": "1234567890.123-abcdef",
  "status": "new|described|finalized|clip_ready|summarized|overflow",
  "phase": "NEW|DESCRIBED|FINALIZED|SUMMARIZED|OVERFLOW",
  "camera": "Doorbell",
  "label": "person",
  "title": "Person at Front Door",
  "message": "A person in blue jacket approaching the door",
  "image_url": "http://YOUR_BUFFER_IP:5055/files/doorbell/1234567890_eventid/snapshot.jpg",
  "video_url": "http://YOUR_BUFFER_IP:5055/files/doorbell/1234567890_eventid/clip.mp4",
  "player_url": "http://YOUR_BUFFER_IP:5055/player",
  "tag": "frigate_1234567890.123-abcdef",
  "timestamp": 1234567890.123,
  "threat_level": 0,
  "critical": false
}
```

### Phase-Specific Messages

When GenAI descriptions are available (Frigate 0.17 with GenAI configured), they are used as the notification title and message. When not available, each phase shows distinct fallback text:

| Status | Message Content |
|--------|----------------|
| `new` | Best description available, or `"Person detected at Doorbell"` |
| `snapshot_ready` | Best description available, or `"Person detected at Doorbell"` |
| `described` | AI description (this IS the new content) |
| `clip_ready` | `"Video available. {best description}"` — combines status context with description |
| `finalized` | GenAI description (this IS the new content) |
| `summarized` | First meaningful line from review summary (truncated to 200 chars) — **skipped** when GenAI returns "No Concerns were found during this time period" |

Every notification includes an `image_url` that is always buffer-based for Companion app reachability: local snapshot once downloaded, or a proxy to Frigate (`/api/events/{event_id}/snapshot.jpg`). The `video_url` field is included once the clip is downloaded.

### Rate Limiting

Notifications are rate-limited to prevent notification flooding:

- **Max 2 notifications per 5 seconds** - Excess notifications are queued
- **Queue size limit: 10** - When exceeded, queue is cleared and an overflow notification is sent
- **Overflow notification** - Directs user to review events on the dashboard

The overflow notification has `status: "overflow"` and `event_id: "overflow_summary"`.

## Security

This application includes several security measures to protect against common vulnerabilities:

- **Path Traversal Protection**: The `/files` and `/delete` endpoints have been hardened to prevent path traversal attacks. All file and folder paths are resolved to their canonical form and checked to ensure they are within the designated storage directory.
- **Information Leakage Prevention**: The `/status` endpoint has been updated to remove sensitive configuration details, such as the MQTT broker and Frigate URL, from the JSON response. This reduces the risk of information leakage.
- **No Shell Injection**: The application uses `subprocess.Popen` without `shell=True`, which prevents shell injection attacks.

It is recommended to run this application in a containerized environment and to restrict access to the API endpoints to trusted users and services.

## Home Assistant Integration

### Binary Sensor for Monitoring

Create a REST binary sensor to monitor the orchestrator:

```yaml
binary_sensor:
  - platform: rest
    name: "Frigate Buffer Online"
    resource: http://YOUR_FRIGATE_BUFFER_IP:5055/status
    method: GET
    value_template: "{{ value_json.online and value_json.mqtt_connected }}"
    scan_interval: 60
    device_class: connectivity
```

### Notification Automation

The buffer sends **clear_tag** (the previous notification's tag) in each payload when the current notification is an update for the same event, so the example automation can clear that previous notification before sending the new one; when the event has ended, the next notification is a new event and no clear_tag is sent. This automation uses a dynamic phone target via a helper. Sound plays only on the initial detection; subsequent updates (clip, AI description) silently replace the notification. **Level 2 (critical) threats bypass phone volume/DND and keep all updates audible.**

```yaml
alias: "Frigate Orchestrator: Phone Notifications"
description: "Ring-style notifications with threat level support."
triggers:
  - trigger: mqtt
    topic: frigate/custom/notifications
actions:
  - variables:
      payload: "{{ trigger.payload_json }}"
      target_phone: "{{ states('input_text.notification_target_phone') }}"
      is_critical: "{{ payload.critical | default(false) }}"
      is_new: "{{ payload.status == 'new' }}"

  - condition: template
    value_template: "{{ target_phone | length > 0 }}"

  - action: "notify.{{ target_phone }}"
    data:
      title: "{{ payload.title }}"
      message: "{{ payload.message }}"
      data:
        tag: "{{ payload.tag }}"
        url: "{{ states('input_text.frigate_buffer_url') }}/player"
        clickAction: "{{ states('input_text.frigate_buffer_url') }}/player"
        image: >-
          {% if payload.image_url %}{{ payload.image_url }}{% endif %}
        video: >-
          {% if payload.video_url %}{{ payload.video_url }}{% endif %}
        # Critical (level 2): always audible, bypasses DND
        # Normal: only "new" gets sound
        importance: >-
          {% if is_critical %}max{% elif is_new %}high{% else %}low{% endif %}
        ttl: 0
        sound: >-
          {% if is_critical or is_new %}default{% else %}none{% endif %}
        channel: >-
          {% if is_critical %}alarm{% else %}general{% endif %}
        push:
          interruption-level: >-
            {% if is_critical %}critical{% elif is_new %}time-sensitive{% else %}passive{% endif %}
        sticky: true
        notification_icon: >-
          {% if is_critical %}mdi:shield-alert{% else %}mdi:shield-check{% endif %}

  - if:
      - condition: template
        value_template: "{{ payload.status in ['clip_ready', 'finalized', 'summarized'] }}"
    then:
      - action: homeassistant.update_entity
        target:
          entity_id: sensor.frigate_feed_raw
      - action: input_number.set_value
        target:
          entity_id: input_number.security_event_index
        data:
          value: 0
```

### Dashboard Card (iframe)

The simplest dashboard setup uses the built-in event viewer via an iframe card. The viewer handles camera selection, event navigation, AI summaries, video playback, and downloads — no HA helpers or sensors needed.

```yaml
type: iframe
url: "http://YOUR_BUFFER_IP:5055/player"
aspect_ratio: "16:9"
```

### Stats Page — API Usage (optional)

The Stats page (`/stats-page`) can display Month to Date API cost and token usage when Home Assistant helpers and REST API are configured. Add to `config.yaml`:

```yaml
ha:
  base_url: "http://YOUR_HA_IP:8123/api"
  token: "YOUR_LONG_LIVED_ACCESS_TOKEN"
  gemini_cost_entity: "input_number.gemini_daily_cost"
  gemini_tokens_entity: "input_number.gemini_total_tokens"
```

Or set `HA_URL` and `HA_TOKEN` environment variables. The cost is formatted to 5 decimal places.

### Required Helpers

Create at Settings > Devices & Services > Helpers.

**1. Notification Target Phone** (Text)
- **Entity ID**: `input_text.notification_target_phone`
- **Value**: Your phone's service name (e.g., `mobile_app_sm_s928u`)

**2. Frigate Buffer URL** (Text)
- **Entity ID**: `input_text.frigate_buffer_url`
- **Value**: Base URL of the buffer (e.g., `http://YOUR_BUFFER_IP:5055`) — **must be reachable from the Companion app** (VPN, Nabu Casa, or same network). Notification images use this base; the buffer proxies snapshots from Frigate when needed.

### Events Sensor (optional)

If you need event data in HA automations or template sensors, create a REST sensor:

```yaml
sensor:
  - platform: rest
    name: "Frigate Feed Raw"
    resource: http://YOUR_FRIGATE_BUFFER_IP:5055/events
    value_template: "{{ value_json.total_count }}"
    json_attributes:
      - events
      - cameras
    scan_interval: 60
```

## Docker Compose

**Option 1: Build from local clone** — Copy and customize the example:

```bash
cp docker-compose.example.yaml docker-compose.yaml
# Edit docker-compose.yaml: update paths, BUFFER_IP, FRIGATE_URL, MQTT_BROKER
docker compose up -d
```

**Option 2: Build from private GitHub (token pull)** — For Dockge, Portainer, or headless servers. Copy `docker-compose.example.yaml` to `docker-compose.yaml`, comment out `build: .`, and uncomment the `build.context` block with your GitHub username and PAT (repo scope):

```yaml
build:
  context: https://YOUR_GITHUB_USERNAME:YOUR_GITHUB_PAT@github.com/jballard86/frigate-event-buffer.git#main
```

See `docker-compose.example.yaml` for the full template with all env vars and optional config bind mount.

Place `config.yaml` in the storage volume — it is found at `/app/storage/config.yaml` automatically. Optional: bind-mount a config file to `/app/config.yaml`.

## Debug Logging

Enable debug logging to troubleshoot issues:

1. **Via config.yaml:**
   ```yaml
   settings:
     log_level: "DEBUG"
   ```

2. **Via environment variable:**
   ```bash
   docker run -e LOG_LEVEL=DEBUG ...
   ```

Debug output includes:
- MQTT messages received (topic, payload size)
- Filtering decisions (camera/label allow/deny, Smart Zone Filtering ignore when event deferred)
- Event state transitions
- File operations (download start/end, transcode progress)
- FFmpeg commands and timing

## FFmpeg Process Safety

The application includes safeguards against hung FFmpeg processes in **VideoService** (`services/video.py`), used by FileManager for transcoding and GIF generation:

- **60-second timeout**: Configurable via `ffmpeg_timeout_seconds` in config
- **Graceful termination**: SIGTERM first, wait 5s, then SIGKILL via `_terminate_process_gracefully`
- **Zombie reaping**: Ensures child processes are properly cleaned up
- **Fallback**: If transcoding fails/times out, original clip is renamed to final path and used

## Event Lifecycle

The buffer listens to **`frigate/events`** for `type: new`, `type: update`, and `type: end`. With Smart Zone Filtering enabled, event creation may be deferred: a `new` or `update` is ignored until the object enters a tracked zone or matches an exception. When creation is triggered by a later `update` (Late Start), the original `start_time` from the payload is used so clips cover the full event.

| Time | MQTT Topic | Phase | Action |
|------|------------|-------|--------|
| T+0s | `frigate/events` (type=new or update) | NEW | Create folder if not deferred by Smart Zone Filtering; send instant notification; fetch local snapshot after delay. With tracked_zones, may defer until object enters tracked zone (Late Start). |
| T+5s | `frigate/{camera}/tracked_object_update` (type=description) | DESCRIBED | Update with AI description |
| T+30s | `frigate/events` (type=end) | - | Download snapshot; request clip via Frigate Export API (POST with `playback`/`name` JSON body; poll by export_id). For consolidated events, each camera gets its own time range and representative event ID from sub-events. |
| T+35s | *(background processing)* | - | Transcode clip, write summary, send `clip_ready`; falls back to per-event clip if export fails or times out. Export failures log full response at WARNING; 404 on clip download is not retried. If **gemini.enabled**, orchestrator starts Gemini analysis in a background thread. |
| T+40s | *(Gemini analyzer, when enabled)* | FINALIZED | Analyzer returns metadata; orchestrator updates state, writes summary/metadata, POSTs description to Frigate API (`/api/events/{id}/description`), sends "finalized" notification to HA. The buffer does **not** publish to `frigate/reviews`. |
| T+45s | `frigate/reviews` (type=genai) | FINALIZED | When Frigate itself produces GenAI: update with metadata from `data.metadata`. (If using the buffer's Gemini analyzer, FINALIZED is already applied in the previous step.) |
| T+55s | Frigate Review Summary API | SUMMARIZED | Fetch cross-camera review summary with configurable time padding, write `review_summary.md` |

### Threat Level Behavior

Events with `potential_threat_level: 2` (Critical) receive special notification handling:

| Threat Level | Initial Alert | Follow-up Updates | DND/Volume |
|-------------|--------------|-------------------|------------|
| 0 (Normal) | Audible | Silent | Respects settings |
| 1 (Suspicious) | Audible | Silent | Respects settings |
| 2 (Critical) | Audible + alarm channel | **All audible** | **Bypasses DND** |

The threat level is determined by Frigate's GenAI analysis based on the `activity_context_prompt` in your Frigate configuration.

## Storage Structure

Events use two layouts; both are included in stats (event counts and storage totals).

**Legacy (per-camera):** Events are organized by camera. Event subdir format: `{timestamp}_{frigate_event_id}` (e.g. Frigate event ID `1234567890.123-abcdef` becomes subdir `1234567890_1234567890.123-abcdef`).

**Consolidated (multi-camera):** Consolidated events live under `events/{ce_id}/` where each `ce_id` is a folder (e.g. `1700000001_abc123`). CE-root files (e.g. `notification.gif`, `review_summary.md`) and per-camera subdirs `events/{ce_id}/{camera}/` (each with `clip.mp4`, `snapshot.jpg`, summary/metadata, etc.) are all counted in storage stats. Event counts treat each CE folder as one event; the Stats page shows an "events" row for consolidated event count.

**Stats totals** include: legacy camera event folders, consolidated `events/{ce_id}/` (CE-root + all `events/{ce_id}/{camera}/`), and the **daily_reports/** and **daily_reviews/** directories (file sizes added to descriptions and total).

```
/app/storage/
├── doorbell/                          # Legacy: one row per camera in Events by Camera
│   ├── 1234567890_1234567890.123-abcdef/
│   │   ├── clip.mp4                # H.264 transcoded video (from Frigate Export API; full event + buffer; downloadable from timeline)
│   │   ├── snapshot.jpg            # Event snapshot
│   │   ├── summary.txt             # Event metadata (human-readable)
│   │   ├── metadata.json           # Structured metadata (threat_level, etc.)
│   │   ├── review_summary.md       # Frigate review summary (markdown)
│   │   ├── notification_timeline.json  # Data pipeline log (Frigate MQTT, clip export request/response, review summarize, HA)
│   │   ├── analysis_result.json        # (Optional) AI analysis result when Gemini analyzer enabled; used by Daily Report
│   │   └── .viewed                 # Review marker (created when marked as reviewed)
│   └── ...
├── events/                             # Consolidated: one "events" row in Events by Camera; storage summed in one "events" bucket
│   └── 1700000001_ce1/
│       ├── notification.gif        # CE-root (counted in storage)
│       ├── review_summary.md       # CE-root (counted in storage)
│       ├── carport/                 # Per-camera: clip.mp4, snapshot.jpg, summary.txt, metadata.json, etc.
│       │   ├── clip.mp4
│       │   ├── snapshot.jpg
│       │   └── ...
│       └── doorbell/
│           └── ...
├── daily_reports/                     # AI daily reports; sizes included in storage total
│   └── 2025-02-12_report.md
└── daily_reviews/                     # Cached Frigate daily reviews; sizes included in storage total
    └── ...
```

Camera folder names are sanitized (lowercase, spaces to underscores). When the Gemini analyzer is enabled, **analysis_result.json** is written in each event folder after clip analysis. The **daily_reports/** directory holds AI-generated daily reports as **YYYY-MM-DD_report.md**. Storage on the Stats page is shown in KB, MB, or GB (chosen per value for readability).

## Troubleshooting

### MQTT Not Connecting

Check `/status` endpoint - `mqtt_connected` should be `true`. Verify:
- MQTT broker is accessible from the container
- No firewall blocking port 1883
- Correct `MQTT_BROKER` environment variable

### Events Not Being Processed

1. Enable debug logging: `LOG_LEVEL=DEBUG`
2. Check for filter messages in logs:
   ```
   Filtered out event from camera 'BackYard' (not configured)
   Filtered out 'car' on 'Doorbell' (allowed: ['person', 'package'])
   Ignoring <event_id> (smart zone filter: not in tracked zones, entered=['road'])
   ```
3. Verify camera names match exactly (case-sensitive)
4. Check that the camera is listed in the `cameras` config
5. **Smart Zone Filtering**: If `event_filters` is configured, events may be deferred until the object enters a tracked zone or matches an exception. Check `tracked_zones` and `exceptions` in your config.

### Screenshots Not Showing in Notifications

Notification images use buffer URLs (local file or `/api/events/{event_id}/snapshot.jpg` proxy). The Companion app must be able to reach `input_text.frigate_buffer_url` to fetch images. Ensure:
- **Same network**: Phone and buffer on same LAN, or
- **VPN / exit node**: Phone routes through a server that can reach the buffer, or
- **Nabu Casa / reverse proxy**: Buffer URL points to a publicly reachable address
- Enable `LOG_LEVEL: DEBUG` to verify `image_url` in published payloads

### Clips Not Downloading

The app uses Frigate's Export API first (`POST /api/export/<camera>/start/<start>/end/<end>` with `Content-Type: application/json` and a JSON body—Frigate 0.17+ requires the body to exist, e.g. `{}` minimum or `{"playback": "realtime", "source": "recordings", "name": "export_<event_id>"}`). Non-200 responses are logged with full `response.text` so Pydantic validation errors are visible. It polls `/api/exports` by `export_id` for up to 90 seconds. For **consolidated events**, each camera is exported with that camera's own time range and a representative event ID (from sub-events), which reduces 404s and wrong footage. If export fails or returns `success: false`, the full raw response is logged at WARNING. If export fails or times out, it falls back to the per-event events API (placeholder clip for consolidated events). HTTP 404 on clip download is treated as "no recording available" and is not retried; retries (up to 3, 5s apart) apply only to HTTP 400 (Not Ready) and other transient errors. If clips still fail:
- Check logs for `Export failed for <event_id>. Status: ... Response: ...` or `No recording available for event ...` or `Clip not ready for ... (HTTP 400), retrying`
- Verify `FRIGATE_URL` is correct and accessible
- Verify Frigate API is responding: `curl http://your-frigate-ip:5000/api/events`
- Camera names must match Frigate config exactly (case-sensitive, e.g. `Doorbell` not `doorbell`)
- Under high server load, exports can timeout; the placeholder fallback provides a clip from the primary event
- The timeline page shows "Clip export request" (with `representative_id` for consolidated events), "Clip export response" (with full Frigate API response for debugging), and "Placeholder clip (events API fallback)" entries

### FFmpeg Timeouts

If transcoding is timing out:
- Increase `ffmpeg_timeout_seconds` in config.yaml
- Check Ryzen CPU load during transcoding
- Consider using a faster preset (already using 'fast')

### Check Container Logs

```bash
docker logs frigate-buffer
docker logs -f frigate-buffer  # Follow logs
```

## Tests

Run all tests from the project root (requires `pip install -r requirements.txt`):

```bash
python -m pytest tests/ -v
```

| Test module | What it tests |
|-------------|----------------|
| `test_ai_analyzer.py` | GeminiAnalysisService: config validation, payload structure, send_text_prompt (success/empty/5xx/missing config), proxy failure handling, flat config and tuning params, prompt file loading, center/smart crop, first/last frame kept, frame_metadata, analyze_clip return value. |
| `test_config_schema.py` | Config validation: valid config loads; missing `cameras` or wrong types (e.g. cameras not a list, mqtt_port not int) cause `SystemExit(1)`; extra root keys allowed; multi_cam/gemini_proxy flatten to flat keys, defaults when omitted, backward compat from gemini, `GEMINI_PROXY_URL` env override, invalid multi_cam type fails. |
| `test_consolidation.py` | ConsolidatedEventManager closing state: `mark_closing` returns True once then False; unknown CE returns False; `schedule_close_timer` does nothing when CE is closing or closed; `get_or_create` does not add events to a closing or closed CE (creates new CE instead). |
| `test_daily_reporter.py` | DailyReporterService: scan for analysis_result.json by date (single and consolidated layout), aggregate event lines format, prompt replacement (report_start_time, report_end_time, report_date_string, list_of_event_json_objects, event_list same as list_of_event_json_objects, known_person_name), save to daily_reports, edge cases (no events, proxy returns None). |
| `test_download_service.py` | DownloadService: export API `success: false` logs warning; export polling and fallback; HTTP 400 retries and HTTP 404 no-retry behavior; snapshot download. |
| `test_event_test.py` | Event Test feature: `run_test_pipeline` behavior (allocation of testN, copy source, generate sidecars, build payload), SSE log stream, and `ai_request.html` generation. |
| `test_file_manager_path_validation.py` | FileManager path safety: `sanitize_camera_name` valid names and stripping of path characters; `create_event_folder` and `create_consolidated_event_folder` raise `ValueError` on path-traversal inputs; valid folder creation succeeds under storage root. |
| `test_frigate_export_watchdog.py` | Export watchdog: `run_once` parses timeline for export IDs, deletes from Frigate when clip present, skips when clip missing; link verification; consolidated event layout. |
| `test_ai_analyzer_proxy_fix.py` | GeminiAnalysisService: proxy retry on ChunkedEncodingError/ProtocolError; success and error paths. |
| `test_web_server_path_safety.py` | Web server path traversal: `/files/` and `/delete/` reject paths outside storage root (404/400). |
| `test_mqtt_auth.py` | MqttClientWrapper: username/password set when provided; `username_pw_set` not called when credentials omitted. |
| `test_storage_stats.py` | FileManager `compute_storage_stats`: empty storage returns zeros; legacy camera/event folders counted; consolidated `events/ce_id/camera/` and CE-root counted; `daily_reports/` and `daily_reviews/` included in total; GET /stats returns storage with `total_display` and `breakdown` using `{value, unit}` (KB/MB/GB). |
| `test_integration_step_5_6.py` | Step 5/6: analysis_result.json persistence (expected fields and partial result still saved), orchestrator _handle_analysis_result calls post_event_description and publish_notification("finalized"), error handling (invalid JSON and proxy 500 do not create file). |
| `test_lifecycle_service.py` | EventLifecycleService: `handle_event_new` (new event and grouped event paths, threads); `process_event_end` (standalone and CE paths); `finalize_consolidated_event` (mark_closing, export, notify, remove). |
| `test_notification_models.py` | NotificationEvent protocol: `EventState` and `ConsolidatedEvent` both satisfy the protocol (attributes required by notifier). |
| `test_notifier_clear_tag.py` | Notification logic: `clear_tag` behavior (sent for updates to same event, omitted for new events); rate limiting and queue overflow. |
| `test_query_caching.py` | EventQueryService caching: TTL and cache key behavior. |
| `test_query_service.py` | EventQueryService: `get_cameras`, `get_events` (camera and consolidated), `get_all_events`, `get_consolidated_events` with mocked filesystem. |
| `test_url_masking.py` | URL credential masking for logs: URLs with user/password are redacted; no user, no port, and no-password cases. |
| `test_video_service.py` | VideoService: `generate_detection_sidecar` (sidecar schema); `generate_gif_from_clip` success and failure. |

## License

MIT
