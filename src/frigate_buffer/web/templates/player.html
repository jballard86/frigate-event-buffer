<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Frigate Event Viewer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
  }

  /* Header */
  .header {
    background: #16213e;
    padding: 12px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #0f3460;
    flex-wrap: wrap;
    gap: 8px;
  }

  .header h1 {
    font-size: 1.1rem;
    color: #e94560;
    white-space: nowrap;
  }

  .header-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  select {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #533483;
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 0.85rem;
    cursor: pointer;
  }

  select:focus { outline: 2px solid #e94560; }

  /* Main single-column layout */
  .main {
    max-width: 800px;
    margin: 0 auto;
    padding: 16px;
  }

  /* Video player */
  .video-container {
    background: #000;
    border-radius: 8px;
    overflow: hidden;
  }

  .video-container video,
  .video-container img {
    width: 100%;
    display: block;
  }

  .no-video {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 240px;
    color: #666;
    font-size: 1.1rem;
  }

  /* Navigation bar */
  .nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 10px;
    gap: 8px;
    flex-wrap: wrap;
  }

  .nav-bar .event-counter {
    color: #999;
    font-size: 0.85rem;
    white-space: nowrap;
  }

  .nav-buttons {
    display: flex;
    gap: 6px;
  }

  button {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #533483;
    border-radius: 6px;
    padding: 7px 14px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.15s;
    white-space: nowrap;
  }

  button:hover:not(:disabled) { background: #533483; }
  button:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-danger { background: #5c1a1a; border-color: #8b2020; }
  .btn-danger:hover:not(:disabled) { background: #8b2020; }

  .btn-download { background: #1a4a1a; border-color: #2d7a2d; }
  .btn-download:hover { background: #2d7a2d; }

  .btn-success { background: #1a4a1a; border-color: #2d7a2d; }
  .btn-success:hover:not(:disabled) { background: #2d7a2d; }

  .btn-mark-all { background: #4a3a1a; border-color: #7a6a2d; }
  .btn-mark-all:hover:not(:disabled) { background: #7a6a2d; }

  .ongoing-badge { margin-left: 8px; padding: 2px 8px; background: #3a4a2a; color: #9fdf9f; border-radius: 4px; font-size: 0.75rem; }

  /* Info cards */
  .info-card {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    padding: 14px;
    margin-top: 10px;
  }

  .info-card h2 {
    font-size: 0.95rem;
    color: #e94560;
    margin-bottom: 8px;
    border-bottom: 1px solid #0f3460;
    padding-bottom: 6px;
  }

  .meta-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 12px;
    font-size: 0.9rem;
  }

  .meta-label { color: #888; font-weight: 500; }
  .meta-value { color: #e0e0e0; word-break: break-word; }

  .description-text {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #ccc;
    white-space: pre-wrap;
  }

  .scene-text {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #aaa;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #333;
  }

  .ai-title {
    font-weight: 600;
    margin-bottom: 6px;
    color: #e0e0e0;
  }

  /* Empty state */
  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #666;
  }

  .empty-state h2 {
    font-size: 1.3rem;
    color: #888;
    margin-bottom: 10px;
  }

  /* Loading */
  .loading {
    text-align: center;
    padding: 40px;
    color: #888;
  }

  /* Updated flash */
  .flash {
    position: fixed;
    top: 8px;
    right: 8px;
    background: #2d7a2d;
    color: #fff;
    padding: 6px 14px;
    border-radius: 6px;
    font-size: 0.8rem;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 100;
  }

  .flash.show { opacity: 1; }

  /* Viewed badge */
  .viewed-badge {
    display: inline-block;
    background: #2d7a2d;
    color: #fff;
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    vertical-align: middle;
  }

  /* Threat level badges */
  .threat-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-left: 8px;
    vertical-align: middle;
  }
  .threat-0 { background: #1a4a1a; color: #7dde7d; }
  .threat-1 { background: #4a3a1a; color: #deb87d; }
  .threat-2 { background: #5c1a1a; color: #ff6b6b; animation: pulse-red 1.5s infinite; }
  @keyframes pulse-red {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* AI Analysis tile: placeholder, title, scene */
  .ai-placeholder { font-style: italic; color: #888; margin: 0 0 10px 0; font-size: 0.9rem; }
  .ai-title { color: #e94560; font-size: 1rem; margin: 0 0 8px 0; font-weight: 600; }
  .ai-scene { margin: 0; line-height: 1.5; color: #ccc; font-size: 0.9rem; }

  /* Responsive: mobile */
  @media (max-width: 600px) {
    .header { padding: 10px 12px; }
    .header h1 { font-size: 0.95rem; }
    .main { padding: 10px; }
    button { padding: 6px 10px; font-size: 0.8rem; }
  }
</style>
<script src="/static/marked.min.js"></script>
<script src="/static/purify.min.js"></script>
</head>
<body>

<div class="header">
  <h1>Frigate Event Viewer</h1>
  <div class="header-controls">
    <select id="cameraSelect">
      <option value="">All Cameras</option>
    </select>
    <select id="filterSelect">
      <option value="unreviewed">Unreviewed</option>
      <option value="all">All Events</option>
      <option value="reviewed">Reviewed</option>
      <option value="saved">Saved</option>
    </select>
    <button class="btn-mark-all" id="btnMarkAll" style="display:none;">Mark All Reviewed</button>
    <a href="/stats-page"><button>Stats</button></a>
    <a href="/daily-review"><button>Daily Review</button></a>
  </div>
</div>

<div class="flash" id="flash"></div>

<div id="mainContent" class="main">
  <div class="loading">Loading events...</div>
</div>

<script>
(function() {
  'use strict';

  let events = [];
  let currentIndex = 0;
  let refreshTimer = null;
  let videoPlaying = false;
  let lastRenderedEventId = null;

  const cameraSelect = document.getElementById('cameraSelect');
  const filterSelect = document.getElementById('filterSelect');
  const mainContent = document.getElementById('mainContent');
  const btnMarkAll = document.getElementById('btnMarkAll');
  const flashEl = document.getElementById('flash');

  // --- Flash ---
  function showFlash(msg) {
    flashEl.textContent = msg;
    flashEl.classList.add('show');
    setTimeout(() => flashEl.classList.remove('show'), 1500);
  }

  // --- API ---
  async function fetchCameras() {
    try {
      const resp = await fetch('/cameras');
      const data = await resp.json();
      data.cameras.forEach(cam => {
        const opt = document.createElement('option');
        opt.value = cam;
        opt.textContent = cam.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        cameraSelect.appendChild(opt);
      });
    } catch (e) {
      console.error('Failed to fetch cameras:', e);
    }
  }

  async function fetchEvents(opts) {
    const filter = filterSelect.value;
    const silent = opts && opts.silent;
    // Back from timeline: fetch all events (don't restrict to camera) so count matches
    const forceAll = !!(opts && opts.forceAll);
    const camera = forceAll ? '' : cameraSelect.value;

    try {
      const base = camera ? `/events/${encodeURIComponent(camera)}` : '/events';
      const resp = await fetch(`${base}?filter=${filter}`);
      const data = await resp.json();
      const newEvents = data.events || [];

      if (silent) {
        // Preserve position by event_id
        const currentId = events[currentIndex] ? events[currentIndex].event_id : null;
        events = newEvents;
        if (currentId) {
          const idx = events.findIndex(e => e.event_id === currentId);
          currentIndex = idx >= 0 ? idx : 0;
        } else {
          currentIndex = 0;
        }
        if (newEvents.length !== events.length) {
          showFlash('Updated');
        }
      } else {
        events = newEvents;
        currentIndex = 0;
        // Back from timeline: seek to same event (do NOT change camera dropdown - keeps full count)
        if (urlCamera && urlSubdir && events.length > 0) {
          const idx = events.findIndex(e => (e.camera || '').toLowerCase() === urlCamera.toLowerCase() && (e.subdir || (e.hosted_clip && e.hosted_clip.split('/').slice(-2, -1)[0])) === urlSubdir);
          if (idx >= 0) {
            currentIndex = idx;
          }
        }
      }

      render();
    } catch (e) {
      console.error('Failed to fetch events:', e);
      if (!silent) {
        mainContent.innerHTML = '<div class="empty-state"><h2>Error loading events</h2><p>Could not connect to the API.</p></div>';
      }
    }
  }

  function getEventPath(ev) {
    if (ev.saved) return 'saved/' + (ev.camera || '') + '/' + (ev.subdir || '');
    return (ev.camera || '') + '/' + (ev.subdir || '');
  }

  async function deleteEvent(eventPath) {
    if (!confirm('Delete this event? This cannot be undone.')) return;
    try {
      const resp = await fetch('/delete/' + eventPath.split('/').map(encodeURIComponent).join('/'), { method: 'POST' });
      if (resp.ok) {
        events.splice(currentIndex, 1);
        if (currentIndex >= events.length) currentIndex = Math.max(0, events.length - 1);
        render();
      } else {
        alert('Failed to delete event.');
      }
    } catch (e) {
      alert('Error deleting event: ' + e.message);
    }
  }

  async function keepEvent(ev) {
    const keepPath = (ev.camera || '') + '/' + (ev.subdir || '');
    try {
      const resp = await fetch('/keep/' + keepPath.split('/').map(encodeURIComponent).join('/'), { method: 'POST' });
      const data = resp.ok ? await resp.json().catch(() => ({})) : {};
      if (resp.ok) {
        events.splice(currentIndex, 1);
        if (currentIndex >= events.length) currentIndex = Math.max(0, events.length - 1);
        showFlash('Event saved');
        render();
      } else {
        alert(data.message || 'Failed to keep event.');
      }
    } catch (e) {
      alert('Error: ' + e.message);
    }
  }

  async function markViewed(eventPath) {
    try {
      await fetch('/viewed/' + eventPath.split('/').map(encodeURIComponent).join('/'), { method: 'POST' });
      // If viewing unreviewed, remove from list; otherwise update in place
      if (filterSelect.value === 'unreviewed') {
        events.splice(currentIndex, 1);
        if (currentIndex >= events.length) currentIndex = Math.max(0, events.length - 1);
      } else {
        events[currentIndex].viewed = true;
      }
      render();
    } catch (e) {
      console.error('Error marking viewed:', e);
    }
  }

  async function markAllViewed() {
    if (!confirm('Mark all events as reviewed?')) return;
    try {
      const resp = await fetch('/viewed/all', { method: 'POST' });
      if (resp.ok) {
        if (filterSelect.value === 'unreviewed') {
          events = [];
          currentIndex = 0;
        } else {
          events.forEach(e => e.viewed = true);
        }
        render();
        showFlash('All marked reviewed');
      }
    } catch (e) {
      console.error('Error marking all viewed:', e);
    }
  }

  // Renders the AI Analysis tile: first line = title (canned or AI) or "future screenshot analysis"; then scene.
  function renderAiAnalysisBlocks(ev) {
    const placeholderText = 'future screenshot analysis';
    const firstLineText = (ev.title != null && ev.title !== '') ? ev.title : placeholderText;
    const firstLineHtml = firstLineText === placeholderText
      ? '<p class="ai-placeholder">' + escapeHtml(firstLineText) + '</p>'
      : '<h3 class="ai-title">' + escapeHtml(firstLineText) + '</h3>';
    const sceneText = ev.scene != null && ev.scene !== '' ? escapeHtml(ev.scene) : 'No scene description.';
    const sceneHtml = '<p class="ai-scene">' + sceneText + '</p>';
    return firstLineHtml + sceneHtml;
  }

  // --- Render ---
  function render() {
    const filter = filterSelect.value;
    btnMarkAll.style.display = (filter === 'saved' || filter === 'test_events') ? 'none' : '';

    const testOpt = document.querySelector('#filterSelect option[value="test_events"]');
    if (events.length === 0) {
      // When no events, still show "Test events" so user can select it to view test runs.
      if (!testOpt) {
        const opt = document.createElement('option');
        opt.value = 'test_events';
        opt.textContent = 'Test events';
        filterSelect.appendChild(opt);
      }
      const filterLabel = filter === 'reviewed' ? 'reviewed' : filter === 'unreviewed' ? 'unreviewed' : filter === 'saved' ? 'saved' : filter === 'test_events' ? 'test' : '';
      mainContent.innerHTML = `
        <div class="empty-state">
          <h2>No Events Found</h2>
          <p>No ${filterLabel} events${cameraSelect.value ? ' for this camera' : ''}.</p>
          <p style="margin-top:16px;"><a href="/stats-page" style="color:#e94560;">View Stats</a></p>
        </div>`;
      return;
    }

    const ev = events[currentIndex];
    const eventPath = getEventPath(ev);

    // Add or remove "Test events" filter option based on current event being consolidated.
    if (ev.consolidated && !testOpt) {
      const opt = document.createElement('option');
      opt.value = 'test_events';
      opt.textContent = 'Test events';
      filterSelect.appendChild(opt);
    } else if (!ev.consolidated && testOpt) {
      if (filterSelect.value === 'test_events') filterSelect.value = 'all';
      testOpt.remove();
    }
    const ts = ev.timestamp ? new Date(parseInt(ev.timestamp) * 1000) : null;
    const endTs = ev.end_timestamp != null ? new Date(Math.round(parseFloat(ev.end_timestamp) * 1000)) : null;
    const dateStr = ts ? ts.toLocaleDateString() : 'Unknown';
    const startTimeStr = ts ? ts.toLocaleTimeString() : '—';
    const endTimeStr = endTs ? endTs.toLocaleTimeString() : 'Ongoing';
    const durationSec = (ts && endTs && ev.end_timestamp != null)
      ? (parseFloat(ev.end_timestamp) - parseFloat(ev.timestamp))
      : null;
    const durationStr = formatDuration(durationSec);
    const title = ev.title || (ev.label || 'Event').replace(/\b\w/g, c => c.toUpperCase()) + ' Detected';
    const description = ev.description || ev.summary || 'No description available.';
    const scene = ev.scene || '';
    const cameraDisplay = ev.camera.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const labelDisplay = (ev.label || 'unknown').replace(/\b\w/g, c => c.toUpperCase());
    const subdir = ev.subdir || (ev.hosted_clip && ev.hosted_clip.split('/').slice(-2, -1)[0]);
    const threatLevel = ev.threat_level || 0;
    const threatLabels = {0: 'Normal', 1: 'Suspicious', 2: 'Critical'};
    const threatBadge = threatLevel > 0
      ? ` <span class="threat-badge threat-${threatLevel}">${threatLabels[threatLevel]}</span>`
      : '';

    const clips = ev.hosted_clips || (ev.hosted_clip ? [{ camera: ev.camera || 'Clip', url: ev.hosted_clip }] : []);
    const primaryClipUrl = ev.hosted_clip || (clips[0] && clips[0].url) || '';

    mainContent.innerHTML = `
      <div class="video-container">
        ${ev.has_clip
          ? `<video id="videoPlayer" controls preload="metadata"
               poster="${ev.has_snapshot ? ev.hosted_snapshot : ''}"
               src="${escapeHtml(primaryClipUrl)}">
               Your browser does not support the video tag.
             </video>
             ${clips.length > 1 ? '' : ''}`
          : ev.has_snapshot
            ? `<img src="${ev.hosted_snapshot}" alt="Snapshot">`
            : `<div class="no-video">No media available</div>`
        }
      </div>

      <div class="nav-bar">
        <div class="nav-buttons" style="align-items: center;">
          <button id="btnNewer" ${currentIndex <= 0 ? 'disabled' : ''}>&#9664; Newer</button>
          <span class="event-counter">${currentIndex + 1} / ${events.length}${ev.viewed ? '<span class="viewed-badge">Reviewed</span>' : ''}${ev.ongoing ? '<span class="ongoing-badge">Event ongoing</span>' : ''}</span>
          <button id="btnOlder" ${currentIndex >= events.length - 1 ? 'disabled' : ''}>Older &#9654;</button>
        </div>
        <div style="flex: 1; display: flex; justify-content: center;">
          ${!ev.viewed ? `<button class="btn-success" id="btnMarkReviewed">Click to Review</button>` : ''}
        </div>
        <div class="nav-buttons">
          ${clips.length > 1 ? `<select id="clipSelectNav">${clips.map((c) =>
            `<option value="${escapeHtml(c.url)}" ${c.url === primaryClipUrl ? 'selected' : ''}>${escapeHtml((c.camera || 'Camera').replace(/_/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase()))}</option>`
          ).join('')}</select>` : ''}
          <div class="dropdown-wrapper" style="position:relative;display:inline-block;">
            <button id="btnActionsDropdown">Actions &#9662;</button>
            <div id="actionsMenu" class="actions-menu" style="display:none;position:absolute;right:0;top:100%;margin-top:4px;background:#16213e;border:1px solid #0f3460;border-radius:6px;min-width:140px;z-index:50;box-shadow:0 4px 12px rgba(0,0,0,0.3);">
              ${ev.has_clip ? `<a id="actionDownload" href="${escapeHtml(primaryClipUrl)}" download style="display:block;padding:8px 12px;color:#e0e0e0;text-decoration:none;font-size:0.85rem;">Download</a>` : ''}
              ${!ev.saved ? `<button type="button" id="actionKeep" style="display:block;width:100%;text-align:left;padding:8px 12px;background:transparent;border:none;color:#e0e0e0;cursor:pointer;font-size:0.85rem;">Keep</button>` : ''}
              <a href="/events/${escapeHtml(eventPath)}/timeline" style="display:block;padding:8px 12px;color:#e0e0e0;text-decoration:none;font-size:0.85rem;">View Timeline</a>
              ${ev.consolidated ? `<a id="actionTest" href="/test-multi-cam?subdir=${encodeURIComponent(ev.saved && ev.camera === 'events' ? 'saved/events/' + subdir : subdir)}" target="_blank" rel="noopener" style="display:block;padding:8px 12px;color:#e0e0e0;text-decoration:none;font-size:0.85rem;">TEST</a>` : ''}
              <button type="button" id="actionDelete" class="btn-danger" style="display:block;width:100%;text-align:left;padding:8px 12px;border:none;cursor:pointer;font-size:0.85rem;border-radius:0;">Delete</button>
            </div>
          </div>
        </div>
      </div>

      <div class="info-card">
        <h2>AI Analysis${threatBadge}</h2>
        <div id="aiAnalysisContainer"></div>
      </div>

      <div class="info-card">
        <h2>Event Details</h2>
        <div class="meta-grid">
          <span class="meta-label">Date</span>
          <span class="meta-value">${escapeHtml(dateStr)}</span>
          <span class="meta-label">Start</span>
          <span class="meta-value">${escapeHtml(startTimeStr)}</span>
          <span class="meta-label">End</span>
          <span class="meta-value">${escapeHtml(endTimeStr)}</span>
          <span class="meta-label">Event length</span>
          <span class="meta-value">${escapeHtml(durationStr)}</span>
          <span class="meta-label">Cameras & Zones</span>
          <span class="meta-value cameras-zones">${((ev.cameras_with_zones && ev.cameras_with_zones.length) ? ev.cameras_with_zones : [{camera: ev.camera, zones: []}])
            .map(c => {
              const cam = escapeHtml((c.camera || '').replace(/_/g, ' ').replace(/\\b\\w/g, ch => ch.toUpperCase()));
              const zones = (c.zones && c.zones.length) ? c.zones.join(', ') : 'No Zones Indicated';
              return cam + ': ' + escapeHtml(zones);
            })
            .join('<br>')}</span>
          <span class="meta-label">Label</span>
          <span class="meta-value">${escapeHtml(labelDisplay)}</span>
          ${ev.severity ? `<span class="meta-label">Severity</span><span class="meta-value">${escapeHtml(ev.severity)}</span>` : ''}
          ${threatLevel > 0 ? `<span class="meta-label">Threat Level</span><span class="meta-value"><span class="threat-badge threat-${threatLevel}">${threatLabels[threatLevel]}</span></span>` : ''}
          <span class="meta-label">Event ID</span>
          <span class="meta-value" style="font-size:0.8rem;color:#888;">${escapeHtml(ev.event_id)}</span>
        </div>
      </div>`;

    // Bind navigation
    const btnNewer = document.getElementById('btnNewer');
    const btnOlder = document.getElementById('btnOlder');
    const btnMarkReviewed = document.getElementById('btnMarkReviewed');
    const video = document.getElementById('videoPlayer');

    if (btnNewer) btnNewer.addEventListener('click', () => { if (currentIndex > 0) { currentIndex--; render(); } });
    if (btnOlder) btnOlder.addEventListener('click', () => { if (currentIndex < events.length - 1) { currentIndex++; render(); } });
    const btnActionsDropdown = document.getElementById('btnActionsDropdown');
    const actionsMenu = document.getElementById('actionsMenu');
    if (btnActionsDropdown && actionsMenu) {
      btnActionsDropdown.addEventListener('click', (e) => {
        e.stopPropagation();
        const open = actionsMenu.style.display !== 'block';
        actionsMenu.style.display = open ? 'block' : 'none';
        if (open) {
          const closeOnce = () => { actionsMenu.style.display = 'none'; document.removeEventListener('click', closeOnce); };
          setTimeout(() => document.addEventListener('click', closeOnce), 0);
        }
      });
    }
    const actionKeep = document.getElementById('actionKeep');
    if (actionKeep) actionKeep.addEventListener('click', () => { keepEvent(ev); if (actionsMenu) actionsMenu.style.display = 'none'; });
    const actionDelete = document.getElementById('actionDelete');
    if (actionDelete) actionDelete.addEventListener('click', () => { deleteEvent(eventPath); if (actionsMenu) actionsMenu.style.display = 'none'; });
    if (btnMarkReviewed) btnMarkReviewed.addEventListener('click', () => markViewed(eventPath));

    // Track video playing state for auto-refresh
    if (video) {
      video.addEventListener('play', () => { videoPlaying = true; });
      video.addEventListener('pause', () => { videoPlaying = false; });
      video.addEventListener('ended', () => { videoPlaying = false; });
    }

    // Clip selector (in nav): switch video src and download link when user picks another camera
    const clipSelectNav = document.getElementById('clipSelectNav');
    if (clipSelectNav) {
      clipSelectNav.addEventListener('change', () => {
        const url = clipSelectNav.value;
        if (video) video.src = url;
        const dl = document.getElementById('actionDownload');
        if (dl) dl.href = url;
      });
    }

    // Populate AI Analysis tile (placeholder, title, scene)
    const aiContainer = document.getElementById('aiAnalysisContainer');
    if (aiContainer) {
      aiContainer.innerHTML = renderAiAnalysisBlocks(ev);
      lastRenderedEventId = ev.event_id;
    }
  }

  function escapeHtml(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  /** Format seconds as human-readable duration (e.g. "2m 30s", "1h 5m 0s"). Returns "—" if invalid. */
  function formatDuration(sec) {
    if (sec == null || typeof sec !== 'number' || sec < 0) return '—';
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const h = Math.floor(m / 60);
    const min = m % 60;
    if (h > 0) return `${h}h ${min}m ${s}s`;
    if (min > 0) return `${min}m ${s}s`;
    return `${s}s`;
  }

  // --- Auto-refresh ---
  function startAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(() => {
      if (!videoPlaying) {
        fetchEvents({ silent: true });
      }
    }, 30000);
  }

  // --- Init ---
  // Honor ?filter= from URL (all, saved, test_events, etc.)
  const urlParams = new URLSearchParams(window.location.search);
  const urlFilter = urlParams.get('filter');
  const urlCamera = urlParams.get('camera');
  const urlSubdir = urlParams.get('subdir');
  if (urlFilter && ['all', 'reviewed', 'unreviewed', 'saved', 'test_events'].includes(urlFilter)) {
    filterSelect.value = urlFilter;
  }
  // Only set camera from URL when NOT coming back from timeline (no subdir) - preserves event count
  if (urlCamera && !urlSubdir) {
    cameraSelect.value = urlCamera;
  }

  cameraSelect.addEventListener('change', () => fetchEvents());
  filterSelect.addEventListener('change', () => {
    fetchEvents();
    startAutoRefresh();
  });
  btnMarkAll.addEventListener('click', markAllViewed);

  (async function init() {
    await fetchCameras();
    if (urlCamera && !urlSubdir) cameraSelect.value = urlCamera;
    await fetchEvents({ forceAll: !!urlSubdir });
    startAutoRefresh();
  })();
})();
</script>
</body>
</html>
