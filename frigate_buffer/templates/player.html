<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Frigate Event Viewer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
  }

  /* Header */
  .header {
    background: #16213e;
    padding: 12px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #0f3460;
    flex-wrap: wrap;
    gap: 8px;
  }

  .header h1 {
    font-size: 1.1rem;
    color: #e94560;
    white-space: nowrap;
  }

  .header-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  select {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #533483;
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 0.85rem;
    cursor: pointer;
  }

  select:focus { outline: 2px solid #e94560; }

  /* Main single-column layout */
  .main {
    max-width: 800px;
    margin: 0 auto;
    padding: 16px;
  }

  /* Video player */
  .video-container {
    background: #000;
    border-radius: 8px;
    overflow: hidden;
  }

  .video-container video,
  .video-container img {
    width: 100%;
    display: block;
  }

  .no-video {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 240px;
    color: #666;
    font-size: 1.1rem;
  }

  /* Navigation bar */
  .nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 10px;
    gap: 8px;
    flex-wrap: wrap;
  }

  .nav-bar .event-counter {
    color: #999;
    font-size: 0.85rem;
    white-space: nowrap;
  }

  .nav-buttons {
    display: flex;
    gap: 6px;
  }

  button {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #533483;
    border-radius: 6px;
    padding: 7px 14px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.15s;
    white-space: nowrap;
  }

  button:hover:not(:disabled) { background: #533483; }
  button:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-danger { background: #5c1a1a; border-color: #8b2020; }
  .btn-danger:hover:not(:disabled) { background: #8b2020; }

  .btn-download { background: #1a4a1a; border-color: #2d7a2d; }
  .btn-download:hover { background: #2d7a2d; }

  .btn-success { background: #1a4a1a; border-color: #2d7a2d; }
  .btn-success:hover:not(:disabled) { background: #2d7a2d; }

  .btn-mark-all { background: #4a3a1a; border-color: #7a6a2d; }
  .btn-mark-all:hover:not(:disabled) { background: #7a6a2d; }

  .ongoing-badge { margin-left: 8px; padding: 2px 8px; background: #3a4a2a; color: #9fdf9f; border-radius: 4px; font-size: 0.75rem; }

  /* Info cards */
  .info-card {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    padding: 14px;
    margin-top: 10px;
  }

  .info-card h2 {
    font-size: 0.95rem;
    color: #e94560;
    margin-bottom: 8px;
    border-bottom: 1px solid #0f3460;
    padding-bottom: 6px;
  }

  .meta-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 12px;
    font-size: 0.9rem;
  }

  .meta-label { color: #888; font-weight: 500; }
  .meta-value { color: #e0e0e0; word-break: break-word; }

  .description-text {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #ccc;
    white-space: pre-wrap;
  }

  .scene-text {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #aaa;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #333;
  }

  .ai-title {
    font-weight: 600;
    margin-bottom: 6px;
    color: #e0e0e0;
  }

  /* Empty state */
  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #666;
  }

  .empty-state h2 {
    font-size: 1.3rem;
    color: #888;
    margin-bottom: 10px;
  }

  /* Loading */
  .loading {
    text-align: center;
    padding: 40px;
    color: #888;
  }

  /* Updated flash */
  .flash {
    position: fixed;
    top: 8px;
    right: 8px;
    background: #2d7a2d;
    color: #fff;
    padding: 6px 14px;
    border-radius: 6px;
    font-size: 0.8rem;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 100;
  }

  .flash.show { opacity: 1; }

  /* Viewed badge */
  .viewed-badge {
    display: inline-block;
    background: #2d7a2d;
    color: #fff;
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    vertical-align: middle;
  }

  /* Threat level badges */
  .threat-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-left: 8px;
    vertical-align: middle;
  }
  .threat-0 { background: #1a4a1a; color: #7dde7d; }
  .threat-1 { background: #4a3a1a; color: #deb87d; }
  .threat-2 { background: #5c1a1a; color: #ff6b6b; animation: pulse-red 1.5s infinite; }
  @keyframes pulse-red {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* AI Analysis expandable blocks */
  .ai-block { margin-bottom: 14px; padding-bottom: 10px; border-bottom: 1px solid #0f3460; }
  .ai-block:last-child { border-bottom: none; margin-bottom: 0; }
  .ai-block-label { font-weight: 600; color: #e94560; font-size: 0.85rem; margin-bottom: 6px; }

  /* Collapsible review summary */
  .summary-excerpt {
    font-size: 0.9rem;
    line-height: 1.5;
    color: #ccc;
  }
  .summary-full {
    display: none;
    margin-top: 8px;
  }
  .summary-full.expanded { display: block; }
  .btn-expand {
    background: none;
    border: 1px solid #533483;
    color: #e94560;
    padding: 4px 12px;
    font-size: 0.8rem;
    margin-top: 8px;
    cursor: pointer;
  }
  .btn-expand:hover { background: #0f3460; }

  /* Rendered markdown content */
  .markdown-content h1, .markdown-content h2, .markdown-content h3 {
    color: #e94560;
    margin: 12px 0 6px 0;
  }
  .markdown-content h1 { font-size: 1.05rem; }
  .markdown-content h2 { font-size: 0.95rem; }
  .markdown-content h3 { font-size: 0.9rem; }
  .markdown-content p { margin: 6px 0; line-height: 1.5; color: #ccc; }
  .markdown-content ul, .markdown-content ol { margin: 6px 0 6px 20px; color: #ccc; }
  .markdown-content li { margin: 3px 0; }
  .markdown-content strong { color: #fff; }
  .markdown-content hr { border-color: #0f3460; margin: 10px 0; }

  /* Responsive: mobile */
  @media (max-width: 600px) {
    .header { padding: 10px 12px; }
    .header h1 { font-size: 0.95rem; }
    .main { padding: 10px; }
    button { padding: 6px 10px; font-size: 0.8rem; }
  }
</style>
<script src="/static/marked.min.js"></script>
<script src="/static/purify.min.js"></script>
</head>
<body>

<div class="header">
  <h1>Frigate Event Viewer</h1>
  <div class="header-controls">
    <select id="cameraSelect">
      <option value="">All Cameras</option>
    </select>
    <select id="filterSelect">
      <option value="unreviewed">Unreviewed</option>
      <option value="all">All Events</option>
      <option value="reviewed">Reviewed</option>
    </select>
    <button class="btn-mark-all" id="btnMarkAll">Mark All Reviewed</button>
    <a href="/stats-page"><button>Stats</button></a>
    <a href="/daily-review"><button>Daily Review</button></a>
  </div>
</div>

<div class="flash" id="flash"></div>

<div id="mainContent" class="main">
  <div class="loading">Loading events...</div>
</div>

<script>
(function() {
  'use strict';

  let events = [];
  let currentIndex = 0;
  let refreshTimer = null;
  let videoPlaying = false;

  const cameraSelect = document.getElementById('cameraSelect');
  const filterSelect = document.getElementById('filterSelect');
  const mainContent = document.getElementById('mainContent');
  const btnMarkAll = document.getElementById('btnMarkAll');
  const flashEl = document.getElementById('flash');

  // --- Flash ---
  function showFlash(msg) {
    flashEl.textContent = msg;
    flashEl.classList.add('show');
    setTimeout(() => flashEl.classList.remove('show'), 1500);
  }

  // --- API ---
  async function fetchCameras() {
    try {
      const resp = await fetch('/cameras');
      const data = await resp.json();
      data.cameras.forEach(cam => {
        const opt = document.createElement('option');
        opt.value = cam;
        opt.textContent = cam.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        cameraSelect.appendChild(opt);
      });
    } catch (e) {
      console.error('Failed to fetch cameras:', e);
    }
  }

  async function fetchEvents(opts) {
    const filter = filterSelect.value;
    const silent = opts && opts.silent;
    // Back from timeline: fetch all events (don't restrict to camera) so count matches
    const forceAll = !!(opts && opts.forceAll);
    const camera = forceAll ? '' : cameraSelect.value;

    try {
      const base = camera ? `/events/${encodeURIComponent(camera)}` : '/events';
      const resp = await fetch(`${base}?filter=${filter}`);
      const data = await resp.json();
      const newEvents = data.events || [];

      if (silent) {
        // Preserve position by event_id
        const currentId = events[currentIndex] ? events[currentIndex].event_id : null;
        events = newEvents;
        if (currentId) {
          const idx = events.findIndex(e => e.event_id === currentId);
          currentIndex = idx >= 0 ? idx : 0;
        } else {
          currentIndex = 0;
        }
        if (newEvents.length !== events.length) {
          showFlash('Updated');
        }
      } else {
        events = newEvents;
        currentIndex = 0;
        // Back from timeline: seek to same event (do NOT change camera dropdown - keeps full count)
        if (urlCamera && urlSubdir && events.length > 0) {
          const idx = events.findIndex(e => (e.camera || '').toLowerCase() === urlCamera.toLowerCase() && (e.subdir || (e.hosted_clip && e.hosted_clip.split('/').slice(-2, -1)[0])) === urlSubdir);
          if (idx >= 0) {
            currentIndex = idx;
          }
        }
      }

      render();
    } catch (e) {
      console.error('Failed to fetch events:', e);
      if (!silent) {
        mainContent.innerHTML = '<div class="empty-state"><h2>Error loading events</h2><p>Could not connect to the API.</p></div>';
      }
    }
  }

  async function deleteEvent(camera, subdir) {
    if (!confirm('Delete this event? This cannot be undone.')) return;
    try {
      const resp = await fetch(`/delete/${camera}/${subdir}`, { method: 'POST' });
      if (resp.ok) {
        events.splice(currentIndex, 1);
        if (currentIndex >= events.length) currentIndex = Math.max(0, events.length - 1);
        render();
      } else {
        alert('Failed to delete event.');
      }
    } catch (e) {
      alert('Error deleting event: ' + e.message);
    }
  }

  async function markViewed(camera, subdir) {
    try {
      await fetch(`/viewed/${camera}/${subdir}`, { method: 'POST' });
      // If viewing unreviewed, remove from list; otherwise update in place
      if (filterSelect.value === 'unreviewed') {
        events.splice(currentIndex, 1);
        if (currentIndex >= events.length) currentIndex = Math.max(0, events.length - 1);
      } else {
        events[currentIndex].viewed = true;
      }
      render();
    } catch (e) {
      console.error('Error marking viewed:', e);
    }
  }

  async function markAllViewed() {
    if (!confirm('Mark all events as reviewed?')) return;
    try {
      const resp = await fetch('/viewed/all', { method: 'POST' });
      if (resp.ok) {
        if (filterSelect.value === 'unreviewed') {
          events = [];
          currentIndex = 0;
        } else {
          events.forEach(e => e.viewed = true);
        }
        render();
        showFlash('All marked reviewed');
      }
    } catch (e) {
      console.error('Error marking all viewed:', e);
    }
  }

  // Renders GenAI blocks: each genai_entries item gets expand/collapse; fallback to single summary/scene/review.
  // Returns { html, blocks } so render() can bind expand handlers with full content.
  function renderAiAnalysisBlocks(ev) {
    const parts = [];
    const blockData = [];
    let blockIdx = 0;
    const genaiEntries = ev.genai_entries || [];

    function addAiBlock(label, excerptHtml, content, format, expandable) {
      const idBase = 'aiBlock' + blockIdx++;
      const expandBtnHtml = expandable
        ? `<button class="btn-expand" id="${idBase}Btn" type="button">Expand</button>`
        : '';
      const fullHtml = expandable
        ? `<div class="summary-full" id="${idBase}Full"></div>`
        : '';
      parts.push(`<div class="ai-block"><div class="ai-block-label">${label}</div><div class="summary-excerpt" id="${idBase}Excerpt">${excerptHtml}</div>${expandBtnHtml}${fullHtml}</div>`);
      if (expandable) {
        blockData.push({ id: idBase, content: content, format: format });
      }
    }

    if (genaiEntries.length > 0) {
      // Render each GenAI event from timeline with its own expand/collapse
      genaiEntries.forEach((entry, i) => {
        const title = entry.title || `GenAI Analysis ${i + 1}`;
        const summary = entry.shortSummary || '';
        const scene = entry.scene || '';
        const timeStr = entry.time ? ` (${entry.time})` : '';
        const content = [summary, scene].filter(Boolean).join('\n\n');
        if (!content) return;
        const isTruncated = content.length > 200;
        const excerpt = isTruncated ? escapeHtml(content.substring(0, 200) + '...') : escapeHtml(content);
        addAiBlock(
          `${escapeHtml(title)}${escapeHtml(timeStr)}`,
          excerpt,
          content,
          'text',
          isTruncated
        );
      });
    }

    // Fallback: single GenAI Summary (title + description) when no genai_entries
    if (genaiEntries.length === 0) {
      const summaryContent = (ev.title || ev.description)
        ? (ev.title ? escapeHtml(ev.title) : '') + (ev.description ? (ev.title ? ' â€” ' : '') + escapeHtml(ev.description) : '')
        : null;
      if (summaryContent) {
        const isTruncated = summaryContent.length > 200;
        const excerpt = isTruncated ? summaryContent.substring(0, 200) + '...' : summaryContent;
        addAiBlock('GenAI Summary', excerpt, summaryContent, 'html', isTruncated);
      }
      if (ev.scene) {
        const isTruncated = ev.scene.length > 200;
        const excerpt = isTruncated ? escapeHtml(ev.scene.substring(0, 200) + '...') : escapeHtml(ev.scene);
        addAiBlock('GenAI Scene', excerpt, ev.scene, 'text', isTruncated);
      }
    }

    // Cross-Camera Review (or "Review Summary" when single camera)
    const reviewSummary = ev.review_summary || '';
    const isNoActivity = /no activity was found|no concerns/i.test(reviewSummary);
    const isSingleCamera = (ev.cameras && ev.cameras.length === 1) || !ev.cameras;
    const reviewLabel = (isSingleCamera && isNoActivity) ? 'Review Summary' : 'Cross-Camera Review';
    if (reviewSummary && !(isNoActivity && genaiEntries.length > 0)) {
      const lines = reviewSummary.split('\n').filter(l => l.trim() && !l.trim().startsWith('#'));
      const previewText = lines.slice(0, 3).join(' ');
      const isTruncated = previewText.length > 200 || lines.length > 3;
      const rawExcerpt = previewText.substring(0, 200);
      const excerpt = escapeHtml(rawExcerpt + (isTruncated ? '...' : ''));
      addAiBlock(escapeHtml(reviewLabel), excerpt, reviewSummary, 'markdown', isTruncated);
    }

    if (parts.length === 0) return { html: '<p class="description-text">No AI analysis available.</p>', blocks: [] };
    return { html: parts.join(''), blocks: blockData };
  }

  // --- Render ---
  function render() {
    const filter = filterSelect.value;
    if (events.length === 0) {
      mainContent.innerHTML = `
        <div class="empty-state">
          <h2>No Events Found</h2>
          <p>No ${filter === 'reviewed' ? 'reviewed' : filter === 'unreviewed' ? 'unreviewed' : ''} events${cameraSelect.value ? ' for this camera' : ''}.</p>
          <p style="margin-top:16px;"><a href="/stats-page" style="color:#e94560;">View Stats</a></p>
        </div>`;
      return;
    }

    const ev = events[currentIndex];
    const ts = ev.timestamp ? new Date(parseInt(ev.timestamp) * 1000) : null;
    const timeStr = ts ? ts.toLocaleString() : 'Unknown';
    const title = ev.title || (ev.label || 'Event').replace(/\b\w/g, c => c.toUpperCase()) + ' Detected';
    const description = ev.description || ev.summary || 'No description available.';
    const scene = ev.scene || '';
    const cameraDisplay = ev.camera.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const labelDisplay = (ev.label || 'unknown').replace(/\b\w/g, c => c.toUpperCase());
    const subdir = ev.subdir || (ev.hosted_clip && ev.hosted_clip.split('/').slice(-2, -1)[0]);
    const threatLevel = ev.threat_level || 0;
    const threatLabels = {0: 'Normal', 1: 'Suspicious', 2: 'Critical'};
    const threatBadge = threatLevel > 0
      ? ` <span class="threat-badge threat-${threatLevel}">${threatLabels[threatLevel]}</span>`
      : '';

    mainContent.innerHTML = `
      <div class="video-container">
        ${ev.has_clip
          ? `<video id="videoPlayer" controls preload="metadata"
               poster="${ev.has_snapshot ? ev.hosted_snapshot : ''}"
               src="${ev.hosted_clip}">
               Your browser does not support the video tag.
             </video>`
          : ev.has_snapshot
            ? `<img src="${ev.hosted_snapshot}" alt="Snapshot">`
            : `<div class="no-video">No media available</div>`
        }
      </div>

      <div class="nav-bar">
        <div class="nav-buttons">
          <button id="btnNewer" ${currentIndex <= 0 ? 'disabled' : ''}>&#9664; Newer</button>
          <button id="btnOlder" ${currentIndex >= events.length - 1 ? 'disabled' : ''}>Older &#9654;</button>
        </div>
        <span class="event-counter">${currentIndex + 1} / ${events.length}${ev.viewed ? '<span class="viewed-badge">Reviewed</span>' : ''}${ev.ongoing ? '<span class="ongoing-badge">Event ongoing</span>' : ''}</span>
        <div class="nav-buttons">
          ${!ev.viewed ? `<button class="btn-success" id="btnMarkReviewed">Reviewed</button>` : ''}
          ${ev.has_clip ? `<a href="${ev.hosted_clip}" download style="text-decoration:none;"><button class="btn-download">Download</button></a>` : ''}
          <a href="/events/${escapeHtml(ev.camera)}/${escapeHtml(subdir)}/timeline" style="text-decoration:none;"><button>View Timeline</button></a>
          <button class="btn-danger" id="btnDelete">Delete</button>
        </div>
      </div>

      <div class="info-card">
        <h2>AI Analysis${threatBadge}</h2>
        <div id="aiAnalysisContainer"></div>
      </div>

      <div class="info-card">
        <h2>Event Details</h2>
        <div class="meta-grid">
          <span class="meta-label">Cameras & Zones</span>
          <span class="meta-value cameras-zones">${((ev.cameras_with_zones && ev.cameras_with_zones.length) ? ev.cameras_with_zones : [{camera: ev.camera, zones: []}])
            .map(c => {
              const cam = escapeHtml((c.camera || '').replace(/_/g, ' ').replace(/\\b\\w/g, ch => ch.toUpperCase()));
              const zones = (c.zones && c.zones.length) ? c.zones.join(', ') : 'No Zones Indicated';
              return cam + ': ' + escapeHtml(zones);
            })
            .join('<br>')}</span>
          <span class="meta-label">Label</span>
          <span class="meta-value">${escapeHtml(labelDisplay)}</span>
          <span class="meta-label">Time</span>
          <span class="meta-value">${escapeHtml(timeStr)}</span>
          ${ev.severity ? `<span class="meta-label">Severity</span><span class="meta-value">${escapeHtml(ev.severity)}</span>` : ''}
          ${threatLevel > 0 ? `<span class="meta-label">Threat Level</span><span class="meta-value"><span class="threat-badge threat-${threatLevel}">${threatLabels[threatLevel]}</span></span>` : ''}
          <span class="meta-label">Event ID</span>
          <span class="meta-value" style="font-size:0.8rem;color:#888;">${escapeHtml(ev.event_id)}</span>
        </div>
      </div>`;

    // Bind navigation
    const btnNewer = document.getElementById('btnNewer');
    const btnOlder = document.getElementById('btnOlder');
    const btnDelete = document.getElementById('btnDelete');
    const btnMarkReviewed = document.getElementById('btnMarkReviewed');
    const video = document.getElementById('videoPlayer');

    if (btnNewer) btnNewer.addEventListener('click', () => { if (currentIndex > 0) { currentIndex--; render(); } });
    if (btnOlder) btnOlder.addEventListener('click', () => { if (currentIndex < events.length - 1) { currentIndex++; render(); } });
    if (btnDelete) btnDelete.addEventListener('click', () => deleteEvent(ev.camera, subdir));
    if (btnMarkReviewed) btnMarkReviewed.addEventListener('click', () => markViewed(ev.camera, subdir));

    // Track video playing state for auto-refresh
    if (video) {
      video.addEventListener('play', () => { videoPlaying = true; });
      video.addEventListener('pause', () => { videoPlaying = false; });
      video.addEventListener('ended', () => { videoPlaying = false; });
    }

    // Populate AI Analysis blocks and bind expand handlers
    const aiResult = renderAiAnalysisBlocks(ev);
    const aiContainer = document.getElementById('aiAnalysisContainer');
    if (aiContainer) {
      aiContainer.innerHTML = aiResult.html;
      aiResult.blocks.forEach((b) => {
        const btn = document.getElementById(b.id + 'Btn');
        const excerptEl = document.getElementById(b.id + 'Excerpt');
        const fullEl = document.getElementById(b.id + 'Full');
        if (!btn || !fullEl) return;
        btn.addEventListener('click', () => {
          const isExpanded = fullEl.classList.toggle('expanded');
          btn.textContent = isExpanded ? 'Collapse' : 'Expand';
          if (isExpanded && fullEl.innerHTML === '') {
            let displayContent;
            if (b.format === 'markdown' && typeof marked !== 'undefined') {
              displayContent = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(b.content)) : marked.parse(b.content);
              fullEl.innerHTML = '<div class="markdown-content">' + displayContent + '</div>';
            } else if (b.format === 'html') {
              fullEl.innerHTML = '<p class="description-text">' + b.content + '</p>';
            } else {
              fullEl.innerHTML = '<p class="description-text">' + escapeHtml(b.content) + '</p>';
            }
          }
          if (isExpanded && excerptEl) excerptEl.style.display = 'none';
          if (!isExpanded && excerptEl) excerptEl.style.display = '';
        });
      });
    }
  }

  function escapeHtml(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // --- Auto-refresh ---
  function startAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(() => {
      if (!videoPlaying) {
        fetchEvents({ silent: true });
      }
    }, 30000);
  }

  // --- Init ---
  // Honor ?filter=all from URL (e.g. "View most recent notification" link)
  const urlParams = new URLSearchParams(window.location.search);
  const urlFilter = urlParams.get('filter');
  const urlCamera = urlParams.get('camera');
  const urlSubdir = urlParams.get('subdir');
  if (urlFilter === 'all') {
    filterSelect.value = 'all';
  }
  // Only set camera from URL when NOT coming back from timeline (no subdir) - preserves event count
  if (urlCamera && !urlSubdir) {
    cameraSelect.value = urlCamera;
  }

  cameraSelect.addEventListener('change', () => fetchEvents());
  filterSelect.addEventListener('change', () => {
    fetchEvents();
    startAutoRefresh();
  });
  btnMarkAll.addEventListener('click', markAllViewed);

  (async function init() {
    await fetchCameras();
    if (urlCamera && !urlSubdir) cameraSelect.value = urlCamera;
    await fetchEvents({ forceAll: !!urlSubdir });
    startAutoRefresh();
  })();
})();
</script>
</body>
</html>
